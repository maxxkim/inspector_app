# Flutter Project Knowledge Base
# Created on Tue May 20 10:53:56 MSK 2025
# Contents from ./lib directory

## File: lib/audit/redux/audit_thunks.dart
```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/audit/redux/audits_actions.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/maximo_repository.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/audit/rs_defect_comment.dart';
import 'package:redux_thunk/redux_thunk.dart';
ThunkAction<AppState> downloadAuditsAction() => (store) async {
 if (!store.state.isConnected) {
 return;
 }
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final audits = await sl<MaximoRepository>().downloadAudits();
 await insertAudits(audits?.member ?? []);
 store.dispatch(readAuditsFromDbAction());
 } catch (err) {
 debugPrint('download audits thunk error: $err');
 } finally {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> readAuditsFromDbAction({bool downloadIfEmpty = false}) =>
 (store) async {
 final savedAudits = await readAllAudits();
 if (savedAudits.isEmpty && downloadIfEmpty) {
 store.dispatch(downloadAuditsAction());
 return;
 }
 store.dispatch(SetAuditsAction(savedAudits));
 };
ThunkAction<AppState> updateAuditsListAction() => (store) async {
 if (!store.state.isConnected) {
 return;
 }
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final response = await sl<MaximoRepository>().downloadAudits();
 var audits = response?.member ?? [];
 final alreadyLoaded =
 store.state.auditsState.audits?.map((e) => e.wonum).toList() ?? [];
 audits = audits
 .where((audit) => !alreadyLoaded.contains(audit.wonum))
 .toList();
 await insertAudits(audits);
 store.dispatch(readAuditsFromDbAction());
 } catch (err) {
 debugPrint('update audits error: $err');
 } finally {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> downloadAuditCheckListsAction(String href) =>
 (store) async {
 if (!store.state.isConnected) {
 return;
 }
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final checkLists = await maximoRepository.downloadAuditChecklists(href);
 if (checkLists?.isNotEmpty ?? false) {
 final wonum = checkLists!.first.woNum;
 if (wonum != null) {
 await insertAuditCheckList(checkLists, wonum);
 store.dispatch(
 readChecklistFromDbAction(wonum, checkLists.first.href ?? ''));
 }
 }
 } catch (err) {
 debugPrint('download audit error: $err');
 } finally {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> readChecklistFromDbAction(String wonum, String href) =>
 (store) async {
 store.dispatch(ShowLoader());
 final checklist = await readAuditChecklists(wonum);
 if (checklist.isNotEmpty) {
 store.dispatch(ReadChecklistAction(checklist));
 store.dispatch(HideLoader());
 } else if (store.state.isConnected) {
 store.dispatch(downloadAuditCheckListsAction(href));
 } else {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> updateChecklistsInMaximo({required String wonum}) =>
 (store) async {
 if (!store.state.isConnected) {
 return;
 }
 await userController.checkAuthorization();
 store.dispatch(SendingAuditCountAction(0));
 store.dispatch(ShowSendingDialogAction(true));
 var count = 0;
 try {
 final List<ChecklistWo> forUploading =
 await readChecklistsForUploading(wonum);
 store.dispatch(TotalToUploadingAction(forUploading.length));
 for (final wo in forUploading) {
 final freshComments =
 await readWoCommentsForUploading(wo.checklistOperationId ?? -1);
 for (var c in freshComments) {
 final commentUploaded = await maximoRepository
 .createRsDefectCommentForChecklistWo(rsComment: c);
 if (commentUploaded) {
 store.dispatch(deleteRsDefectCommentAction(
 comment: c,
 parentId: wo.parentId ?? -1,
 checklistwoid: wo.checklistOperationId ?? -1));
 }
 debugPrint(
 'comment ${commentUploaded ? 'uploaded' : 'Failed to upload'}: ${c.comment}');
 }
 final url = await maximoRepository.getWoHref(wo.checklistWoId!);
 if (url == null) {
 continue;
 }
 try {
 final updated = await maximoRepository.updateChecklistWo(
 url: url,
 status: wo.chlistStatus,
 checked: wo.rsMasterpoint,
 factor: wo.numberof,
 );
 final List<String> images =
 await readWoImagesPaths(checklistwoid: wo.checklistWoId!);
 final doclinks = wo.doclinks?.href;
 if (doclinks != null) {
 debugPrint('uploading image to: $doclinks');
 await maximoRepository.uploadImagesToMaximo(
 paths: images,
 docLink: doclinks,
 table: ChecklistWo.chlwoImagesTable,
 );
 }
 if (updated) {
 count++;
 store.dispatch(SendingAuditCountAction(count));
 resetChanged(wo.checklistWoId!);
 }
 } catch (err) {
 debugPrint('Cannot update ${wo.number} in Maximo');
 }
 }
 } finally {
 debugPrint('sent count: $count');
 await Future.delayed(const Duration(seconds: 1));
 store.dispatch(ShowSendingDialogAction(false));
 }
 };
ThunkAction<AppState> addCommentAction({
 required String wonum,
 required int checklistwoid,
 required int checklistOperationId,
 required int parentId,
 required String comment,
 required String siteId,
}) =>
 (store) async {
 final rsComment = RsDefectComment(
 comment: comment,
 checklistOperationId: checklistOperationId,
 orgId: 'TPS',
 notCreateSr: true,
 woNum: wonum,
 checklistWoId: checklistwoid,
 siteId: siteId,
 );
 await insertRsDefectComments([rsComment]);
 await updateChanged(checklistwoid);
 final checklist = await readLastLevel(wonum, parentId);
 if (checklist.isNotEmpty) {
 store.dispatch(UpdateLastLevelAction(checklist));
 }
 store.dispatch(findAndUpdateWoInLevels(checklistwoid: checklistwoid));
 };
ThunkAction<AppState> deleteRsDefectCommentAction({
 required RsDefectComment comment,
 required int parentId,
 required int checklistwoid,
}) =>
 (store) async {
 await deleteRsDefectCommentDb(comment);
 final checklist = await readLastLevel(comment.woNum ?? '', parentId);
 if (checklist.isNotEmpty) {
 store.dispatch(UpdateLastLevelAction(checklist));
 }
 store.dispatch(findAndUpdateWoInLevels(checklistwoid: checklistwoid));
 };
ThunkAction<AppState> updateStatusAction(
 {required String wonum,
 required int checklistwoid,
 required int parentId,
 required String status}) =>
 (store) async {
 await updateStatus(checklistwoid, status);
 final checklist = await readLastLevel(wonum, parentId);
 if (checklist.isNotEmpty) {
 store.dispatch(UpdateLastLevelAction(checklist));
 }
 store.dispatch(findAndUpdateWoInLevels(checklistwoid: checklistwoid));
 };
ThunkAction<AppState> updateFactorAction(
 {required String wonum,
 required int checklistwoid,
 required int parentId,
 required double factor}) =>
 (store) async {
 await updateFactor(checklistwoid, factor);
 final checklist = await readLastLevel(wonum, parentId);
 if (checklist.isNotEmpty) {
 store.dispatch(UpdateLastLevelAction(checklist));
 }
 store.dispatch(findAndUpdateWoInLevels(checklistwoid: checklistwoid));
 };
ThunkAction<AppState> updateCheckedAction(
 {required String wonum,
 required int checklistwoid,
 required int parentId,
 required int checked}) =>
 (store) async {
 await updateChecked(checklistwoid, checked);
 final checklist = await readLastLevel(wonum, parentId);
 if (checklist.isNotEmpty) {
 store.dispatch(UpdateLastLevelAction(checklist));
 }
 store.dispatch(findAndUpdateWoInLevels(checklistwoid: checklistwoid));
 };
ThunkAction<AppState> findAndUpdateWoInLevels({
 required int checklistwoid,
}) =>
 (store) async {
 final updated = await readWo(checklistwoid);
 final newLevels = [...store.state.auditsState.checkListLevels];
 void update(List<ChecklistWo> input) {
 for (int i = 0; i < input.length; i++) {
 final old = input[i];
 if (old.checklistWoId == updated.checklistWoId) {
 input[i] = updated;
 }
 if (old.checklist.isNotEmpty) {
 update(old.checklist);
 }
 }
 }
 for (var level in newLevels) {
 update(level);
 }
 store.dispatch(UpdateLevelsAction(newLevels));
 };
ThunkAction<AppState> visitInLevels({
 required int checklistwoid,
}) =>
 (store) async {
 final currentLevels = store.state.auditsState.checkListLevels.last;
 for (final w in currentLevels) {
 if (w.checklistWoId == checklistwoid) {
 w.visited = true;
 }
 }
 };
ThunkAction<AppState> deleteAuditAction(String wonum) => (store) async {
 store.dispatch(ShowLoader());
 await deleteAudit(wonum);
 store.dispatch(ClearAuditsStateAction());
 await store.dispatch(readAuditsFromDbAction());
 store.dispatch(HideLoader());
 };
```

## File: lib/audit/redux/audits_actions.dart
```dart
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
sealed class AuditsAction {}
class SelectedAuditAction extends AuditsAction {
 final WorkTaskMobile audit;
 SelectedAuditAction(this.audit);
}
class SetAuditsAction extends AuditsAction {
 final List<WorkTaskMobile>? audits;
 SetAuditsAction(this.audits);
}
class ReadChecklistAction extends AuditsAction {
 final List<ChecklistWo> checklist;
 ReadChecklistAction(this.checklist);
}
class NextAction extends AuditsAction {
 final List<ChecklistWo> checklist;
 NextAction({required this.checklist});
}
class PreviousAction extends AuditsAction {}
class CrumbAction extends AuditsAction {
 final String crumb;
 CrumbAction({required this.crumb});
}
class BackCrumbAction extends AuditsAction {}
class UpdateLastLevelAction extends AuditsAction {
 final List<ChecklistWo> last;
 UpdateLastLevelAction(this.last);
}
class UpdateLevelsAction extends AuditsAction {
 UpdateLevelsAction(this.levels);
 final List<List<ChecklistWo>> levels;
}
class AddAuditAction extends AuditsAction {
 final WorkTaskMobile audit;
 AddAuditAction(this.audit);
}
class RemoveAuditAction extends AuditsAction {
 final WorkTaskMobile audit;
 RemoveAuditAction(this.audit);
}
class TotalToUploadingAction extends AuditsAction {
 final int? total;
 TotalToUploadingAction(this.total);
}
class SendingAuditCountAction extends AuditsAction {
 final int? count;
 SendingAuditCountAction(this.count);
}
class ShowSendingDialogAction extends AuditsAction {
 final bool show;
 ShowSendingDialogAction(this.show);
}
class ClearAuditsStateAction extends AuditsAction {}
class ShowUncheckedOnly extends AuditsAction {
 final bool uncheckedOnly;
 ShowUncheckedOnly(this.uncheckedOnly);
}
```

## File: lib/audit/redux/audits_reducer.dart
```dart
import 'package:inspector_tps/audit/redux/audits_actions.dart';
import 'package:inspector_tps/audit/redux/audits_state.dart';
AuditsState auditsReducer(AuditsState state, dynamic action) {
 if (action is SetAuditsAction) {
 return state.copyWith(audits: action.audits);
 } else if (action is SelectedAuditAction) {
 return state.copyWith(selectedAudit: action.audit);
 } else if (action is ReadChecklistAction) {
 return state.copyWith(checkListLevels: [action.checklist]);
 } else if (action is NextAction) {
 final next = [...state.checkListLevels];
 next.add(action.checklist);
 return state.copyWith(checkListLevels: next);
 } else if (action is PreviousAction) {
 final previous = [...state.checkListLevels];
 if (previous.isNotEmpty) {
 previous.removeLast();
 return state.copyWith(checkListLevels: previous);
 }
 } else if (action is UpdateLastLevelAction) {
 final levels = [...state.checkListLevels];
 levels.removeLast();
 levels.add(action.last);
 return state.copyWith(checkListLevels: levels);
 } else if (action is UpdateLevelsAction) {
 return state.copyWith(checkListLevels: action.levels);
 } else if (action is CrumbAction) {
 final crumbs = [...state.breadcrumbs];
 crumbs.add(action.crumb);
 return state.copyWith(breadcrumbs: crumbs);
 } else if (action is BackCrumbAction) {
 final previous = [...state.breadcrumbs];
 if (previous.isNotEmpty) {
 previous.removeLast();
 return state.copyWith(breadcrumbs: previous);
 }
 } else if (action is SendingAuditCountAction) {
 return state.copyWith(sendingAuditCount: action.count);
 } else if (action is ShowSendingDialogAction) {
 return state.copyWith(showSendingDialog: action.show);
 } else if (action is TotalToUploadingAction) {
 return state.copyWith(totalToUploading: action.total);
 } else if (action is ClearAuditsStateAction) {
 return AuditsState.initial();
 } else if (action is ShowUncheckedOnly) {
 return state.copyWith(showUncheckedOnly: action.uncheckedOnly);
 }
 return state;
}
```

## File: lib/audit/redux/audits_state.dart
```dart
import 'package:flutter/cupertino.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
@immutable
class AuditsState {
 final List<WorkTaskMobile>? audits;
 final WorkTaskMobile? selectedAudit;
 final List<List<ChecklistWo>> checkListLevels;
 final List<String> breadcrumbs;
 final int sendingAuditCount;
 final bool showSendingDialog;
 final int totalToUploading;
 final bool showUncheckedOnly;
 const AuditsState._({
 this.selectedAudit,
 this.audits,
 required this.checkListLevels,
 required this.breadcrumbs,
 required this.showSendingDialog,
 required this.sendingAuditCount,
 required this.totalToUploading,
 required this.showUncheckedOnly,
 });
 factory AuditsState.initial() => const AuditsState._(
 checkListLevels: [],
 breadcrumbs: [],
 sendingAuditCount: -1,
 totalToUploading: 0,
 showSendingDialog: false,
 showUncheckedOnly: false,
 );
 AuditsState copyWith({
 List<WorkTaskMobile>? audits,
 WorkTaskMobile? selectedAudit,
 List<List<ChecklistWo>>? checkListLevels,
 List<String>? breadcrumbs,
 bool? isTechExploitation,
 bool? showSendingDialog,
 int? sendingAuditCount,
 int? totalToUploading,
 bool? showUncheckedOnly,
 }) {
 return AuditsState._(
 audits: audits ?? this.audits,
 selectedAudit: selectedAudit ?? this.selectedAudit,
 checkListLevels: checkListLevels ?? this.checkListLevels,
 breadcrumbs: breadcrumbs ?? this.breadcrumbs,
 showSendingDialog: showSendingDialog ?? this.showSendingDialog,
 sendingAuditCount: sendingAuditCount ?? this.sendingAuditCount,
 totalToUploading: totalToUploading ?? this.totalToUploading,
 showUncheckedOnly: showUncheckedOnly ?? this.showUncheckedOnly,
 );
 }
}
```

## File: lib/audit/view/audit_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class AuditCard extends StatelessWidget {
 const AuditCard({super.key, required this.audit});
 final WorkTaskMobile audit;
 @override
 Widget build(BuildContext context) {
 final textTheme = Theme.of(context).textTheme;
 final dateStyle =
 textTheme.labelMedium?.copyWith(fontWeight: FontWeight.bold);
 Widget dateRow;
 if (audit.isKvosm) {
 dateRow = Row(
 children: [
 Text(audit.quarterDescription ?? '', style: dateStyle),
 const Spacer(),
 Text(audit.yearDescription ?? '', style: dateStyle),
 ],
 );
 } else {
 dateRow = Row(
 children: [
 if (audit.weekDescription != null) ...[
 Text((audit.weekDescription ?? ''), style: dateStyle),
 _minSpan
 ],
 Text((audit.monthDescription ?? ''), style: dateStyle),
 _minSpan,
 Text((audit.yearDescription ?? ''), style: dateStyle),
 ],
 );
 }
 return Card(
 elevation: 0,
 color: Colors.grey.shade100,
 child: Padding(
 padding: const EdgeInsets.all(8.0),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text(audit.wonum ?? '', style: dateStyle),
 _minGap,
 Text(
 audit.description ?? '',
 style: textTheme.bodyMedium,
 ),
 _minGap,
 dateRow,
 ],
 ),
 ),
 );
 }
}
const _minGap = SizedBox(height: 10);
const _minSpan = SizedBox(width: 20);
```

## File: lib/audit/view/audits_list.dart
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/audit/redux/audits_actions.dart';
import 'package:inspector_tps/audit/view/audit_card.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class AuditsList extends StatelessWidget {
 const AuditsList({super.key, required this.audits});
 final List<WorkTaskMobile> audits;
 @override
 Widget build(BuildContext context) {
 return Padding(
 padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10),
 child: ListView.builder(
 itemCount: audits.length,
 itemBuilder: (context, index) {
 final audit = audits[index];
 return InkWell(
 child: AuditCard(audit: audit),
 onTap: () {
 context.store.dispatch(SelectedAuditAction(audit));
 context.go(AppRoute.auditDetailed.route);
 },
 );
 },
 ),
 );
 }
}
```

## File: lib/audit/view/audits_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/audit/view/audits_list.dart';
import 'package:inspector_tps/audit/view/no_audits_widget.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/unsupported_for_groups_widget.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class AuditsView extends StatelessWidget {
 const AuditsView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 distinct: true,
 onInit: (store) {
 if (store.state.userState.showAudits) {
 store.dispatch(readAuditsFromDbAction(downloadIfEmpty: true));
 }
 },
 builder: (context, vm) {
 print('show audits: ${vm.showAudits}');
 return vm.showAudits
 ? Scaffold(
 appBar: AppBar(
 title: Text(Txt.audits),
 actions: [
 PopupMenuButton<int>(
 onSelected: (index) => handleClick(context, index),
 itemBuilder: (context) => [
 PopupMenuItem<int>(
 value: 0, child: Text(Txt.updateAuditsList)),
 ],
 ),
 ],
 ),
 body: vm.showLoader
 ? const Center(child: CircularProgressIndicator())
 : vm.audits.isEmpty
 ? const NoAuditsWidget()
 : AuditsList(audits: vm.audits),
 )
 : const UnsupportedForGroupsWidget();
 });
 }
 void handleClick(BuildContext context, int index) {
 switch (index) {
 case 0:
 context.store.dispatch(updateAuditsListAction());
 break;
 default:
 break;
 }
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 bool get showLoader => appState.showLoader;
 List<WorkTaskMobile> get audits => appState.auditsState.audits ?? [];
 bool get showAudits => appState.userState.showAudits;
 @override
 List<Object?> get props => [audits, showLoader];
}
```

## File: lib/audit/view/checklist/bread_crumbs_widget.dart
```dart
import 'package:flutter/material.dart';
class BreadCrumbsWidget extends StatelessWidget {
 const BreadCrumbsWidget({
 super.key,
 required this.crumbs,
 required this.tapCrumbCallback,
 });
 final List<String> crumbs;
 final Function(int) tapCrumbCallback;
 @override
 Widget build(BuildContext context) {
 return Wrap(
 children: generateCrumbs(context, crumbs),
 );
 }
 List<Widget> generateCrumbs(BuildContext context, List<String> input) {
 final activeColor = Theme.of(context).colorScheme.primary;
 final list = <Widget>[];
 for (var i = 0; i < input.length; i++) {
 final isLast = i == input.length - 1;
 list.add(
 Padding(
 padding: const EdgeInsets.symmetric(vertical: 3.0),
 child: Crumb(
 name: input[i],
 index: i,
 color: isLast ? Colors.black : activeColor,
 tapCrumbCallback: tapCrumbCallback,
 isLast: isLast,
 ),
 ),
 );
 }
 return list;
 }
}
class Crumb extends StatelessWidget {
 const Crumb({
 super.key,
 required this.name,
 required this.color,
 required this.index,
 required this.tapCrumbCallback,
 required this.isLast,
 });
 final String name;
 final Color color;
 final int index;
 final Function(int) tapCrumbCallback;
 final bool isLast;
 @override
 Widget build(BuildContext context) {
 return InkWell(
 child: Text(
 '$name ${isLast ? '\u{2193}' : '\u{2192}'} ',
 style: TextStyle(color: color, fontWeight: FontWeight.bold),
 ),
 onTap: () {
 tapCrumbCallback(index);
 },
 );
 }
}
```

## File: lib/audit/view/checklist/checklist_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/audit/redux/audits_actions.dart';
import 'package:inspector_tps/audit/view/checklist/images_row.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
class ChecklistCard extends StatelessWidget {
 const ChecklistCard(
 {super.key, required this.wo, required this.isTechExploitation});
 final ChecklistWo wo;
 final bool isTechExploitation;
 @override
 Widget build(BuildContext context) {
 final colorScheme = Theme.of(context).colorScheme;
 final downloadedComments = wo.rsDefectcomment
 ?.where((c) => c.rsDefectCommentId != null)
 .toList() ??
 [];
 final bool hasDownloadedComments = downloadedComments.isNotEmpty;
 final myComments = wo.rsDefectcomment
 ?.where((c) => c.rsDefectCommentId == null)
 .toList() ??
 [];
 final bool hasMyComments = myComments.isNotEmpty;
 final wonum = wo.woNum;
 final id = wo.checklistWoId;
 final parentId = wo.parentId;
 final isLeaf = wo.checklist.isEmpty && !(wo.hasChildren ?? false);
 return GestureDetector(
 onTap: () async {
 final asMap = wo.toMap();
 debugPrint(asMap.toString());
 debugPrint('isLeaf: $isLeaf');
 debugPrint(
 'comments: ${wo.rsDefectcomment?.fold('', (agr, e) => '$agr ${e.comment};')}');
 setVisited(wo.checklistWoId!);
 if (context.mounted) {
 context.store
 .dispatch(visitInLevels(checklistwoid: wo.checklistWoId!));
 }
 final next = wo.checklist;
 if (next.isNotEmpty) {
 context.store.dispatch(NextAction(checklist: next));
 context.store.dispatch(CrumbAction(crumb: wo.description ?? ''));
 if (next.first.checklist.isEmpty) {
 for (var wo in next) {
 context.store.dispatch(
 findAndUpdateWoInLevels(checklistwoid: wo.checklistWoId!));
 }
 }
 }
 },
 child: Card(
 color: (wo.hasChildren ?? false) && (wo.visited ?? false)
 ? Colors.deepPurple.withOpacity(0.1)
 : null,
 key: ValueKey<int>(wo.checklistWoId!),
 child: Padding(
 padding: const EdgeInsets.all(8.0),
 child: Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Flexible(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 if (wo.number != null)
 Text(
 wo.number!,
 style: const TextStyle(fontWeight: FontWeight.bold),
 ),
 Text(
 wo.description ?? '',
 ),
 if (isLeaf)
 Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 DropdownButton(
 value: ChecklistWo
 .statusMap[int.parse(wo.chlistStatus ?? '0')],
 items: getStatuses
 .map((e) => DropdownMenuItem(
 value: e, child: Text(e)))
 .toList(),
 onChanged: (status) {
 final wonum = wo.woNum;
 final id = wo.checklistWoId;
 final parentId = wo.parentId;
 if (status != null &&
 wonum != null &&
 id != null &&
 parentId != null) {
 context.store.dispatch(updateStatusAction(
 wonum: wonum,
 checklistwoid: id,
 parentId: parentId,
 status: ChecklistWo
 .statusDescriptionMap[status]!));
 }
 }),
 if (wo.hasFactor)
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Text(
 Txt.factorValue,
 style: TextStyle(color: colorScheme.primary),
 ),
 DropdownButton(
 value: wo.numberof ?? 1.0,
 items: factors
 .map((e) => DropdownMenuItem(
 value: e,
 child: Text(e.toInt().toString())))
 .toList(),
 onChanged: (factor) {
 final wonum = wo.woNum;
 final id = wo.checklistWoId;
 final parentId = wo.parentId;
 if (factor != null &&
 wonum != null &&
 id != null &&
 parentId != null) {
 context.store
 .dispatch(updateFactorAction(
 wonum: wonum,
 checklistwoid: id,
 parentId: parentId,
 factor: factor,
 ));
 }
 }),
 ],
 ),
 if (hasDownloadedComments) ...[
 Text(
 '${Txt.downloadedComments}:',
 style:
 const TextStyle(fontWeight: FontWeight.bold),
 ),
 ...downloadedComments.map(
 (comment) => Padding(
 padding: const EdgeInsets.only(bottom: 2.0),
 child: Text(
 comment.comment ?? '',
 style: const TextStyle(
 fontStyle: FontStyle.italic,
 fontWeight: FontWeight.w500,
 fontSize: 12,
 ),
 ),
 ),
 )
 ],
 if (hasMyComments) ...[
 Padding(
 padding: const EdgeInsets.only(bottom: 5.0),
 child: Text(
 '${Txt.myComments}:',
 style: const TextStyle(
 fontWeight: FontWeight.bold),
 ),
 ),
 ...myComments.map(
 (comment) => Padding(
 padding: const EdgeInsets.only(bottom: 2.0),
 child: InkWell(
 onTap: () {
 deleteRsDefectCommentDialog(
 context, comment, wo);
 },
 child: Text(
 comment.comment ?? '',
 style: const TextStyle(
 fontStyle: FontStyle.italic,
 fontWeight: FontWeight.w500,
 fontSize: 15,
 color: accent),
 ),
 ),
 ),
 )
 ],
 const SizedBox(height: 10),
 SingleChildScrollView(
 child: Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 InkWell(
 onTap: () =>
 addRsDefectComment(context, wo),
 child: Text(
 Txt.addComment,
 style: TextStyle(
 color: colorScheme.primary,
 ),
 )),
 if (wo.images.length < 6)
 IconButton(
 onPressed: () {
 if (wonum != null && id != null) {
 attachPhoto(context,
 wonum: wonum,
 checklistwoid: wo.checklistWoId,
 mode: CameraMode.checklist);
 }
 },
 icon: const Icon(
 Icons.camera_alt_outlined)),
 Checkbox(
 value: wo.rsMasterpoint,
 onChanged: (value) {
 if (wonum != null &&
 id != null &&
 parentId != null) {
 context.store.dispatch(
 updateCheckedAction(
 wonum: wonum,
 checklistwoid: id,
 parentId: parentId,
 checked: (value ?? false) ? 1 : 0,
 ),
 );
 }
 },
 ),
 ],
 ),
 ),
 if (id != null && wonum != null)
 ImagesRow(
 images: wo.images,
 checklistWoId: wo.checklistWoId!,
 mode: CameraMode.checklist,
 ),
 ],
 ),
 ],
 ),
 ),
 ],
 ),
 ),
 ),
 );
 }
 List<String> get getStatuses {
 final statuses = ChecklistWo.statusMap.values.toList();
 return isTechExploitation ? statuses : statuses.sublist(1);
 }
 List<double> get factors => List.generate(100, (i) => i + 1, growable: false);
 bool _showTeReportData(ChecklistWo wo) {
 return wo.classid != null &&
 wo.classid!.isNotEmpty &&
 (wo.number?.startsWith('k') ?? false);
 }
}
```

## File: lib/audit/view/checklist/checklist_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/audit/redux/audits_actions.dart';
import 'package:inspector_tps/audit/redux/audits_state.dart';
import 'package:inspector_tps/audit/view/checklist/bread_crumbs_widget.dart';
import 'package:inspector_tps/audit/view/checklist/checklist_widget.dart';
import 'package:inspector_tps/audit/view/checklist/download_checklist_widget.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class ChecklistView extends StatelessWidget {
 const ChecklistView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 distinct: true,
 converter: (store) => _VM(store.state),
 onInit: (store) {
 final wonum = store.state.auditsState.selectedAudit?.wonum;
 final href = store.state.auditsState.selectedAudit?.href;
 if (wonum != null) {
 store.dispatch(
 store.dispatch(readChecklistFromDbAction(wonum, href ?? '')));
 }
 },
 onDidChange: (_, vm) {
 if (vm.showSentAuditResultDialog) {
 sentChecklistsResultDialog(
 context,
 vm.audit!.wonum!,
 );
 context.store.dispatch(ShowSendingDialogAction(false));
 }
 },
 builder: (context, vm) {
 return Scaffold(
 appBar: AppBar(
 centerTitle: false,
 titleSpacing: 0,
 title: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text(
 vm.audit?.wonum ?? '',
 style: const TextStyle(
 fontSize: 12, fontWeight: FontWeight.bold),
 ),
 Text(
 vm.audit?.description ?? '',
 style: const TextStyle(fontSize: 13),
 ),
 ],
 ),
 leading: InkWell(
 onTap: () => _handleBack(context, vm),
 child: const Icon(
 Icons.arrow_back,
 color: Colors.white,
 ),
 ),
 actions: [
 IconButton(
 onPressed: () {
 context.store
 .dispatch(ShowUncheckedOnly(!vm.showUncheckedOnly));
 },
 icon: vm.showUncheckedOnly
 ? const Icon(Icons.check_box)
 : const Icon(Icons.check_box_outline_blank)),
 PopupMenuButton<int>(
 onSelected: (item) => _handleMenuClick(context, item, vm),
 itemBuilder: (context) => [
 PopupMenuItem(value: 0, child: Text(Txt.deleteAudit)),
 PopupMenuItem(value: 1, child: Text(Txt.sendAuditToMaximo)),
 ],
 ),
 ],
 ),
 floatingActionButton: FloatingActionButton(
 heroTag: 'checklist',
 backgroundColor: primary,
 onPressed: () => _handleBack(context, vm),
 child: const Icon(Icons.arrow_back, size: 40),
 ),
 body: vm.showLoader
 ? const Center(child: CircularProgressIndicator())
 : (vm.hasChecklist)
 ? Padding(
 padding: const EdgeInsets.all(8.0),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 BreadCrumbsWidget(
 crumbs: vm.breadCrumbs,
 tapCrumbCallback: _onCrumbTap,
 ),
 const SizedBox(height: 10),
 Expanded(
 child: ChecklistWidget(
 checklist: vm.checklist,
 isTechExploitation: vm.isTechExploitation,
 )),
 ],
 ),
 )
 : DownloadChecklistWidget(href: vm.audit?.href ?? ''),
 );
 },
 );
 }
 void _handleBack(BuildContext context, _VM vm) {
 if (vm.navigateToAuditsList) {
 context.go(AppRoute.audit.route);
 }
 context.store.dispatch(PreviousAction());
 context.store.dispatch(BackCrumbAction());
 }
 void _handleMenuClick(BuildContext context, int index, _VM vm) {
 final audit = vm.audit!;
 switch (index) {
 case 0:
 deleteAuditDialog(context, audit);
 break;
 case 1:
 if (vm.isConnected) {
 context.store.dispatch(updateChecklistsInMaximo(wonum: audit.wonum!));
 } else {
 ScaffoldMessenger.of(context).showSnackBar(SnackBar(
 content: Text(Txt.internetNeededForDataSending),
 ));
 }
 break;
 default:
 break;
 }
 }
 void _onCrumbTap(int index) {
 final size = appStore.state.auditsState.breadcrumbs.length;
 final stepsBack = size - index - 1;
 for (int i = 0; i < stepsBack; i++) {
 appStore.dispatch(PreviousAction());
 appStore.dispatch(BackCrumbAction());
 }
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 AuditsState get auditsState => appState.auditsState;
 WorkTaskMobile? get audit => auditsState.selectedAudit;
 bool get navigateToAuditsList => auditsState.checkListLevels.length < 2;
 List<List<ChecklistWo>> get levels => auditsState.checkListLevels;
 List<ChecklistWo> get _checklist => levels.isNotEmpty ? levels.last : [];
 List<ChecklistWo> get checklist =>
 showUncheckedOnly ? filterUnchecked(_checklist) : _checklist;
 bool get hasChecklist => _checklist.isNotEmpty;
 bool get showLoader => appState.showLoader;
 List<String> get breadCrumbs => appState.auditsState.breadcrumbs;
 bool get isTechExploitation => breadCrumbs.contains(Txt.tech);
 bool get showSentAuditResultDialog => auditsState.showSendingDialog;
 bool get isConnected => appState.isConnected;
 bool get showUncheckedOnly => auditsState.showUncheckedOnly;
 @override
 List<Object?> get props => [
 audit,
 _checklist,
 levels.hashCode,
 showSentAuditResultDialog,
 showLoader,
 isConnected,
 showUncheckedOnly,
 ];
}
```

## File: lib/audit/view/checklist/checklist_widget.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/audit/view/checklist/checklist_card.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
class ChecklistWidget extends StatelessWidget {
 const ChecklistWidget(
 {super.key, required this.checklist, required this.isTechExploitation});
 final List<ChecklistWo> checklist;
 final bool isTechExploitation;
 @override
 Widget build(BuildContext context) {
 return ListView.builder(
 itemCount: checklist.length + 1,
 itemBuilder: (context, index) {
 if (index == checklist.length) {
 return const SizedBox(height: 100);
 }
 final chl = checklist[index];
 return ChecklistCard(
 wo: chl,
 isTechExploitation: isTechExploitation,
 );
 });
 }
}
```

## File: lib/audit/view/checklist/download_checklist_widget.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
class DownloadChecklistWidget extends StatelessWidget {
 const DownloadChecklistWidget({super.key, required this.href});
 final String href;
 @override
 Widget build(BuildContext context) {
 return Padding(
 padding: const EdgeInsets.all(16.0),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.center,
 children: [
 const Spacer(),
 const Icon(Icons.download_for_offline, size: 100, color: Colors.grey),
 _gap,
 Text(Txt.downloadDescription,
 textAlign: TextAlign.center,
 style:
 const TextStyle(fontSize: 18, fontWeight: FontWeight.w600)),
 _gap,
 Text(Txt.downloadDescription2,
 textAlign: TextAlign.center,
 style: const TextStyle(fontSize: 14, color: Colors.grey)),
 const Spacer(),
 ElevatedButton(
 onPressed: () {
 context.store.dispatch(downloadAuditCheckListsAction(href));
 },
 child: Text(Txt.downloadChecklist)),
 _gap,
 ],
 ),
 );
 }
 static const _gap = SizedBox(height: 50);
}
```

## File: lib/audit/view/checklist/images_row.dart
```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/dialogs.dart';
class ImagesRow extends StatelessWidget {
 const ImagesRow(
 {super.key,
 required this.images,
 this.checklistWoId,
 this.wonum,
 required this.mode});
 final List<String> images;
 final int? checklistWoId;
 final String? wonum;
 final CameraMode mode;
 @override
 Widget build(BuildContext context) {
 return Row(children: [
 ...images.map((e) => Preview(
 path: e,
 checklistWoId: checklistWoId,
 wonum: wonum,
 cameraMode: mode,
 ))
 ]);
 }
}
class Preview extends StatelessWidget {
 const Preview(
 {super.key,
 required this.path,
 this.checklistWoId,
 this.wonum,
 required this.cameraMode});
 final String path;
 final int? checklistWoId;
 final String? wonum;
 final CameraMode cameraMode;
 @override
 Widget build(BuildContext context) {
 return InkWell(
 onTap: () {
 displayPhotoDialog(
 context,
 path,
 id: checklistWoId,
 wonum: wonum,
 mode: cameraMode,
 );
 },
 child: ClipRRect(
 borderRadius: BorderRadius.circular(20),
 child: Container(
 padding: const EdgeInsets.all(5),
 height: 50,
 width: 50,
 child: Image.file(File(path), fit: BoxFit.fill),
 ),
 ),
 );
 }
}
```

## File: lib/audit/view/no_audits_widget.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
class NoAuditsWidget extends StatelessWidget {
 const NoAuditsWidget({super.key});
 @override
 Widget build(BuildContext context) {
 return Center(
 child: Column(
 children: [
 const Spacer(),
 Text(Txt.noAudits),
 const SizedBox(height: 100),
 ElevatedButton(
 onPressed: () {
 context.store.dispatch(downloadAuditsAction());
 },
 child: Text(Txt.downloadAudits)),
 const Spacer(),
 ],
 ),
 );
 }
}
```

## File: lib/auth/presentation/login_screen.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/auth/redux/actions.dart';
import 'package:inspector_tps/auth/redux/user_state.dart';
import 'package:inspector_tps/core/change_contour_dialog.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/connection_indicator.dart';
class LoginScreen extends StatefulWidget {
 const LoginScreen({super.key});
 @override
 State<LoginScreen> createState() => _LoginScreenState();
}
class _LoginScreenState extends State<LoginScreen> {
 late final TextEditingController usernameController;
 late final TextEditingController passwordController;
 bool _passwordVisible = false;
 bool _keyboardVisible = false;
 @override
 void initState() {
 final creds = userController.getCreds();
 usernameController = TextEditingController(text: creds.$1);
 passwordController = TextEditingController(text: creds.$2);
 super.initState();
 }
 @override
 Widget build(BuildContext context) {
 _keyboardVisible = MediaQuery.of(context).viewInsets.bottom != 0;
 return StoreConnector<AppState, bool>(
 converter: (store) => store.state.hasError,
 distinct: true,
 onDidChange: (_, hasError) {
 if (hasError) {
 context.go(AppRoute.error.route);
 }
 },
 builder: (context, vm) {
 return Container(
 decoration: const BoxDecoration(
 gradient: LinearGradient(
 begin: Alignment.topRight,
 end: Alignment.bottomLeft,
 colors: [
 Colors.deepPurple,
 Colors.black,
 ],
 )),
 child: Scaffold(
 backgroundColor: Colors.transparent,
 body: Stack(
 children: [
 _page(),
 const Positioned(
 top: 16, left: 10, child: ConnectionIndicator()),
 ],
 ),
 ),
 );
 });
 }
 Widget _page() {
 return Padding(
 padding: const EdgeInsets.symmetric(horizontal: 32.0),
 child: Column(
 children: [
 const Spacer(),
 ..._logo(),
 const SizedBox(height: 20),
 if (!_keyboardVisible) _avatar(),
 const SizedBox(height: 30),
 _inputField(Txt.login, usernameController),
 const SizedBox(height: 30),
 _inputField(Txt.pwd, passwordController, isPassword: true),
 const SizedBox(height: 50),
 _loginBtn(),
 const Spacer(),
 ],
 ),
 );
 }
 Widget _avatar() {
 return GestureDetector(
 onLongPress: _changeContour,
 child: Container(
 decoration: BoxDecoration(
 border: Border.all(color: Colors.white, width: 2),
 shape: BoxShape.circle),
 child: const Icon(Icons.person, color: Colors.white, size: 60),
 ),
 );
 }
 List<Widget> _logo() {
 return [
 const Text(Txt.tps, style: TextStyle(fontSize: 28, color: Colors.white)),
 const Text(Txt.estate,
 style: TextStyle(fontSize: 18, color: Colors.white)),
 ];
 }
 Widget _inputField(String hintText, TextEditingController controller,
 {isPassword = false}) {
 var border = OutlineInputBorder(
 borderRadius: BorderRadius.circular(18),
 borderSide: const BorderSide(color: Colors.white));
 return TextField(
 style: const TextStyle(color: Colors.white),
 controller: controller,
 decoration: InputDecoration(
 hintText: hintText,
 hintStyle: const TextStyle(color: Colors.white),
 enabledBorder: border,
 focusedBorder: border,
 suffixIcon: isPassword
 ? IconButton(
 icon: Icon(
 _passwordVisible ? Icons.visibility : Icons.visibility_off,
 color: Colors.white,
 ),
 onPressed: () {
 setState(() {
 _passwordVisible = !_passwordVisible;
 });
 },
 )
 : null,
 ),
 obscureText: isPassword && !_passwordVisible,
 );
 }
 Widget _loginBtn() {
 return SizedBox(
 height: 56,
 child: StoreConnector<AppState, _VM>(
 converter: (store) => _VM(
 showLoader: store.state.showLoader,
 userState: store.state.userState),
 onDidChange: (_, vm) {
 if (vm.isAuthorized) {
 context.go(getInitialHomeRoute(vm.userState.user));
 }
 },
 distinct: true,
 builder: (context, vm) {
 return vm.showLoader
 ? const SizedBox(
 height: 56, width: 56, child: CircularProgressIndicator())
 : ElevatedButton(
 onPressed: () {
 final user = usernameController.text.trim();
 final pwd = passwordController.text.trim();
 if (user.isEmpty || pwd.isEmpty) {
 return;
 }
 context.store.dispatch(loginThunk(user, pwd));
 debugPrint('$user:$pwd');
 },
 style: ElevatedButton.styleFrom(
 shape: const StadiumBorder(),
 padding: const EdgeInsets.symmetric(vertical: 16),
 ),
 child: const SizedBox(
 width: double.infinity,
 child: Text(
 Txt.enter,
 textAlign: TextAlign.center,
 style: TextStyle(fontSize: 20),
 )),
 );
 }),
 );
 }
 void _changeContour() {
 changeContourDialog(context);
 }
}
class _VM extends Equatable {
 final bool showLoader;
 final UserState userState;
 const _VM({required this.showLoader, required this.userState});
 bool get isAuthorized => userState.isAuthorized;
 @override
 List<Object?> get props => [showLoader, userState];
}
```

## File: lib/auth/presentation/user_profile_view.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/auth/redux/actions.dart';
import 'package:inspector_tps/core/api/endpoints.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:inspector_tps/ppr/utils.dart';
class UserProfileView extends StatelessWidget {
 const UserProfileView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, UserModel?>(
 converter: (store) => store.state.userState.user,
 distinct: true,
 builder: (context, user) {
 final groups = user?.userGroups ?? [];
 return Scaffold(
 appBar: AppBar(
 centerTitle: false,
 title: FutureBuilder(
 future: getAppInfo(),
 builder: (context, snapshot) {
 return snapshot.hasData
 ? Text(snapshot.data ?? '',
 style: const TextStyle(fontSize: 14))
 : const SizedBox.shrink();
 },
 ),
 actions: [
 TextButton.icon(
 onPressed: () {
 context.store.dispatch(logoutThunk);
 context.go(AppRoute.login.route);
 },
 icon: const Icon(Icons.exit_to_app_rounded, color: gray),
 label:
 const Text(Txt.logout, style: TextStyle(color: gray)))
 ],
 ),
 body: Stack(
 children: [
 Image.asset(
 "assets/splash.png",
 fit: BoxFit.cover,
 height: double.infinity,
 width: double.infinity,
 alignment: Alignment.center,
 ),
 Container(color: Colors.white.withOpacity(0.85)),
 StoreConnector<AppState, bool>(
 converter: (store) => store.state.isDev,
 builder: (context, dev) {
 return Column(
 children: [
 gap20,
 tile(
 '${user?.displayName ?? ''} (${user?.loginID ?? ''})',
 Icons.account_circle),
 tile(user?.email ?? '', Icons.email),
 tile(user?.userRole ?? '',
 Icons.person_pin_circle_outlined),
 tile(getHost, Icons.network_ping),
 tile(
 '${(user?.defaultOrg ?? '')} ${(user?.defaultSite ?? '')}',
 Icons.domain),
 tile(Txt.groups, Icons.groups),
 Padding(
 padding:
 const EdgeInsets.symmetric(horizontal: 16.0),
 child: SizedBox(
 height: 255,
 child: ListView.builder(
 itemCount: groups.length,
 itemBuilder: (context, index) => Text(
 groups[index],
 style: const TextStyle(
 fontSize: 12,
 fontWeight: FontWeight.bold,
 ),
 ),
 ),
 ),
 ),
 gap10,
 ],
 );
 }),
 ],
 ),
 );
 });
 }
 Widget tile(String text, IconData icon) => ListTile(
 leading: Icon(icon),
 title: Text(text),
 );
}
```

## File: lib/auth/redux/actions.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/api/maximo_session.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/local_storages/shared_prefs.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';
@immutable
abstract class UserStateAction {}
class UserAction implements UserStateAction {
 final UserModel? userModel;
 UserAction(this.userModel);
}
ThunkAction<AppState> loginThunk(String login, String pwd) => (store) async {
 store.dispatch(ShowLoader());
 final user = await userController.login(login: login, pwd: pwd);
 store.dispatch(UserAction(user));
 if (user != null) {
 userController.saveUser(user);
 final groups = user.userGroups ?? [];
 if(groups.contains(hoemp) && !areSitesLoaded) {
 store.dispatch(downloadSitesAction());
 }
 }
 store.dispatch(HideLoader());
 };
void logoutThunk(Store<AppState> store) {
 userController.logout();
 prefs.remove(PrefsKey.user);
 resetAllDbData();
 store.dispatch(ClearStateAction());
 saveDev(false);
 sl<MaximoSession>().config();
 connectivityService.initConnectivityStatus();
}
```

## File: lib/auth/redux/reducer.dart
```dart
import 'package:inspector_tps/auth/redux/actions.dart';
import 'package:inspector_tps/auth/redux/user_state.dart';
UserState userReducer(UserState state, dynamic action) {
 if (action is UserAction) {
 return state.copyWith(
 user: action.userModel,
 );
 }
 return state;
}
```

## File: lib/auth/redux/user_state.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
@immutable
class UserState {
 const UserState._({
 this.user,
 });
 factory UserState.initial() => const UserState._();
 final UserModel? user;
 UserState copyWith({
 UserModel? user,
 }) {
 return UserState._(
 user: user ?? this.user,
 );
 }
 bool get isAuthorized => user != null;
 bool get showAudits {
 final groups = user?.userGroups ?? [];
 return groups.contains(ceew) ||
 groups.contains(hoemp) ||
 groups.contains(bdd);
 }
 bool get showPpr => true;
 bool get showRz => true;
}
```

## File: lib/auth/user_controller.dart
```dart
import 'dart:convert';
import 'package:flutter/cupertino.dart';
import 'package:inspector_tps/auth/redux/actions.dart';
import 'package:inspector_tps/auth/user_repository.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/data/local_storages/shared_prefs.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:inspector_tps/data/models/user/user_request.dart';
class UserController {
 UserController(this.api);
 final UserRepository api;
 Future<UserModel?> login({required String login, required String pwd}) async {
 saveCreds(login, pwd);
 try {
 api.resetCookie();
 final response =
 await api.login(UserRequest(identifier: login, password: pwd));
 if (response) {
 final whoAmI = await api.whoAmI();
 final response = await api.userGroups();
 final groups = response.$1;
 final role = response.$2;
 final user = whoAmI?.copyWith(userGroups: groups, userRole: role);
 return user;
 }
 } catch (err) {
 debugPrint('login error: $err');
 }
 return null;
 }
 Future<bool> isAuthorized() async {
 final user = await api.whoAmI();
 return user != null;
 }
 Future<void> checkAuthorization() async {
 var authorized = await isAuthorized();
 if (authorized) {
 return;
 }
 api.resetCookie();
 final creds = getCreds();
 await api.login(UserRequest(identifier: creds.$1, password: creds.$2),
 dispatchError: false);
 authorized = await isAuthorized();
 if (!authorized) {
 appStore.dispatch(logoutThunk);
 }
 }
 static const _splitter = '^:^';
 void logout() {
 api.resetCookie();
 }
 void saveCreds(String login, String pwd) {
 prefs.setString(PrefsKey.creds, '$login$_splitter$pwd');
 }
 (String, String) getCreds() {
 final creds = prefs.getString(PrefsKey.creds);
 if (creds == null) {
 return ('', '');
 }
 final split = creds.split(_splitter);
 return (split.first, split.last);
 }
 void saveUser(UserModel user) {
 final json = user.toJson();
 prefs.setString(PrefsKey.user, jsonEncode(json));
 }
 void getUser() {
 final userString = prefs.getString(PrefsKey.user);
 try {
 final user = jsonDecode(userString ?? '');
 appStore.dispatch(UserAction(UserModel.fromJson(user)));
 } catch (err) {
 debugPrint('user decode err: $err');
 }
 }
}
```

## File: lib/auth/user_repository.dart
```dart
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/core/api/endpoints.dart';
import 'package:inspector_tps/core/api/maximo_session.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:inspector_tps/data/models/user/user_request.dart';
class UserRepository {
 UserRepository(this._session);
 final MaximoSession _session;
 Future<bool> login(UserRequest request, {bool dispatchError = true}) async {
 final response = await _session.get(Endpoints.login,
 headers: request.headers, dispatchError: dispatchError);
 debugPrint(
 'response code: ${response?.statusCode} headers: ${response?.headers}');
 if (response is Response && response.statusCode == 200) {
 return true;
 }
 return false;
 }
 Future<UserModel?> whoAmI({bool dispatchError = false}) async {
 try {
 final response =
 await _session.get(Endpoints.whoAmI, dispatchError: dispatchError);
 final user = UserModel.fromJson(response.data);
 debugPrint(user.toString());
 return user;
 } catch (ex) {
 debugPrint('err whoAmI: $ex');
 return null;
 }
 }
 Future<(List<String>?, String)> userGroups() async {
 try {
 final Response urlResponse = await _session.get(Endpoints.userGroups);
 final data = (urlResponse.data['member'] as List<dynamic>).first;
 final href = data['href'];
 final groupsResponse = await _session.get(href);
 final groups = groupsResponse.data['groupuser'] as List<dynamic>;
 String role = '';
 try {
 role = ((groupsResponse.data['ipcrole'] as List<dynamic>).first
 as Map<String, dynamic>)['description'];
 } catch (ex) {
 debugPrint('cannot get role: $ex');
 }
 final res = <String>[];
 for (var map in groups) {
 res.add(map['groupname']);
 }
 return (res, role);
 } catch (ex) {
 debugPrint('err userGroups: $ex');
 return (null, '');
 }
 }
 void resetCookie() {
 _session.resetCookie();
 }
}
```

## File: lib/claims/claim_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/audit/view/checklist/images_row.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
class ClaimCard extends StatelessWidget {
 const ClaimCard({super.key, required this.sr, required this.user});
 final Sr sr;
 final UserModel user;
 @override
 Widget build(BuildContext context) {
 Widget header = Row(
 mainAxisAlignment: MainAxisAlignment.start,
 children: [
 Text(sr.ticketid ?? '', style: _style),
 span10,
 Text(sr.siteid ?? '', style: _style),
 span10,
 if (sr.reportdate != null)
 Text(dateTimeFromIso(sr.reportdate ?? ''), style: _style),
 ],
 );
 return Card(
 elevation: 0,
 color: sr.sent ? Colors.green.withOpacity(0.2) : primary.withOpacity(0.2),
 child: Padding(
 padding: const EdgeInsets.all(5.0),
 child: Stack(
 children: [
 Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 if (sr.sent) header,
 if (sr.sent)
 Text('${Txt.from} ${sr.fromwho ?? ''}', style: _style),
 Text(
 sr.locdesc ?? '',
 style: _style,
 ),
 SizedBox(
 width: MediaQuery.of(context).size.width * .8,
 child: Text(
 sr.description ?? '',
 maxLines: 3,
 style: _style,
 ),
 ),
 if (!sr.sent)
 Row(
 mainAxisAlignment: MainAxisAlignment.end,
 children: [
 ImagesRow(
 wonum: sr.changedate,
 images: sr.images,
 mode: CameraMode.claim),
 IconButton(
 onPressed: () {
 attachPhoto(context,
 wonum: sr.changedate ?? '',
 checklistwoid: null,
 mode: CameraMode.claim);
 },
 icon: const Icon(Icons.photo_camera)),
 IconButton(
 onPressed: () {
 final isConnected = context.store.state.isConnected;
 if (!isConnected) {
 infoDialog(context,
 message: Txt.internetNeededForDataSending);
 } else {
 context.store.dispatch(sendClaimToMaximoAction(
 savedSr: sr, user: user));
 }
 },
 icon: const Icon(Icons.send)),
 ],
 ),
 ],
 ),
 Positioned(
 top: 0,
 right: 0,
 child: InkWell(
 onTap: () {
 deleteClaimDialog(context, sr);
 },
 child: const Icon(Icons.close)))
 ],
 ),
 ),
 );
 }
}
TextStyle _style = const TextStyle(fontSize: 10);
```

## File: lib/claims/claims_list.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/claims/claim_card.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
class ClaimsList extends StatelessWidget {
 const ClaimsList({super.key, required this.srList, required this.user});
 final List<Sr> srList;
 final UserModel user;
 @override
 Widget build(BuildContext context) {
 return ListView.builder(
 itemCount: srList.length,
 itemBuilder: (context, index) {
 final sr = srList[index];
 return InkWell(
 child: ClaimCard(sr: sr, user: user),
 onTap: () {
 debugPrint(sr.toString());
 },
 );
 },
 );
 }
}
```

## File: lib/claims/claims_tabs_switcher.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/claims/redux/claims_actions.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
class ClaimsTabsSwitcher extends StatelessWidget {
 const ClaimsTabsSwitcher({super.key});
 @override
 Widget build(BuildContext context) {
 final buttonWidth = (MediaQuery.of(context).size.width - 32 - 20) / 2;
 return StoreConnector<AppState, ClaimsTab>(
 converter: (store) => store.state.claimsState.selectedTab,
 builder: (context, tab) {
 return ToggleButtons(
 onPressed: (int index) {
 context.store.dispatch(SetClaimsTabAction(_tabs[index]));
 },
 borderRadius: const BorderRadius.all(Radius.circular(4)),
 borderWidth: 5,
 borderColor: grayMiddle,
 selectedColor: primary,
 color: primary,
 constraints: BoxConstraints(
 minHeight: 30.0,
 minWidth: buttonWidth,
 ),
 isSelected: [
 tab == ClaimsTab.rzList,
 tab == ClaimsTab.createClaim,
 ],
 children: [
 _getTabWidget(0, buttonWidth, tab),
 _getTabWidget(1, buttonWidth, tab),
 ],
 );
 });
 }
}
const _tabs = ClaimsTab.values;
Widget _getTabWidget(
 int index,
 double width,
 ClaimsTab selectedTab,
) {
 final tab = _tabs[index];
 final bool isSelected = tab == selectedTab;
 return Container(
 height: 30,
 width: width,
 color: isSelected ? Colors.white : grayMiddle,
 child: Center(
 child: Text(
 tab.value,
 style: const TextStyle(
 fontWeight: FontWeight.bold,
 fontSize: 12,
 ),
 ),
 ));
}
```

## File: lib/claims/claims_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/claims/claims_tabs_switcher.dart';
import 'package:inspector_tps/claims/create_claim_dialog.dart';
import 'package:inspector_tps/claims/create_claim_view.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/claims/rz_view.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/core/widgets/round_count_widget.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class ClaimsView extends StatelessWidget {
 const ClaimsView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 distinct: true,
 onInit: (store) {
 store.dispatch(readSrListAndAssetsFromDbAction());
 },
 builder: (context, vm) {
 final body = !vm.isDutyEng
 ? CreateClaimView(
 localClaims: vm.localClaims,
 sentClaims: vm.sentClaims,
 user: vm.user,
 )
 : Column(
 children: [
 gap20,
 const ClaimsTabsSwitcher(),
 gap10,
 if (vm.selectedTab == ClaimsTab.rzList)
 const Expanded(child: RzView()),
 if (vm.selectedTab == ClaimsTab.createClaim)
 Expanded(
 child: CreateClaimView(
 localClaims: vm.localClaims,
 sentClaims: vm.sentClaims,
 user: vm.user,
 ),
 ),
 ],
 );
 return Scaffold(
 backgroundColor: positive.withOpacity(0.05),
 appBar: AppBar(
 centerTitle: true,
 title: vm.isDutyEng
 ? Row(
 mainAxisAlignment: MainAxisAlignment.center,
 children: [
 span40,
 Text(
 Txt.rzs,
 style: const TextStyle(fontSize: 13),
 ),
 span10,
 RoundCountWidget(count: vm.count),
 ],
 )
 : Text(Txt.claims),
 actions: [
 PopupMenuButton<int>(
 icon: const Icon(Icons.more_vert),
 onSelected: (index) => _handleMenuClick(context, index, vm),
 itemBuilder: (context) => [
 PopupMenuItem<int>(
 value: 5,
 child: Text(
 Txt.createNewClaim,
 )),
 PopupMenuItem<int>(
 value: 0,
 child: Text(
 Txt.sendSavedClaims,
 )),
 PopupMenuItem<int>(
 value: 1,
 child: Text(
 Txt.sendSavedRz,
 )),
 PopupMenuItem<int>(
 value: 2,
 child: Text(
 Txt.renewAssets,
 )),
 if (vm.user.isCo)
 PopupMenuItem<int>(
 value: 6,
 child: Text(
 Txt.downloadSites,
 )),
 PopupMenuItem<int>(
 value: 3,
 child: Text(
 Txt.clearRzList,
 style: const TextStyle(color: Colors.red),
 )),
 PopupMenuItem<int>(
 value: 4,
 child: Text(
 Txt.clearPreApprovedRz,
 style: const TextStyle(),
 )),
 ],
 ),
 ],
 ),
 body: vm.showLoader
 ? const Padding(
 padding:
 EdgeInsets.symmetric(vertical: 50.0, horizontal: 16),
 child: LoaderWithDescription(),
 )
 : body,
 );
 });
 }
 void _handleMenuClick(BuildContext context, int index, _VM vm) {
 switch (index) {
 case 0:
 _processSavedClaims(context, vm.user);
 break;
 case 1:
 _processSavedRzs(context);
 break;
 case 2:
 downloadAssets(context);
 break;
 case 3:
 context.store.dispatch(deleteAllRzAction(vm.allRzWonums));
 case 4:
 context.store.dispatch(deletePreAcceptedRzAction());
 case 5:
 createClaimDialog(context, vm.user);
 break;
 case 6:
 context.store.dispatch(downloadSitesAction());
 break;
 default:
 break;
 }
 }
 void _processSavedClaims(BuildContext context, UserModel user) {
 final isConnected = context.store.state.isConnected;
 if (!isConnected) {
 infoDialog(context, message: Txt.internetNeededForDataSending);
 } else {
 sendAllSavedSr(context, user);
 }
 }
 void _processSavedRzs(BuildContext context) {
 final isConnected = context.store.state.isConnected;
 if (!isConnected) {
 infoDialog(context, message: Txt.internetNeededForDataSending);
 } else {
 context.store.dispatch(sendLocallyProcessedRzs());
 }
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 bool get showLoader => appState.showLoader;
 ClaimsTab get selectedTab => appState.claimsState.selectedTab;
 List<WorkTaskMobile> get rzList => appState.claimsState.rzList ?? [];
 List<String> get allRzWonums => rzList.map((rz) => rz.wonum ?? '').toList();
 int get count => rzList.length;
 List<Sr> get claims => appState.claimsState.srList ?? [];
 List<Sr> get localClaims => claims.where((sr) => sr.isLocal).toList();
 List<Sr> get sentClaims => claims.where((sr) => sr.sent).toList();
 bool get isDutyEng => appState.userState.user?.isDutyEng ?? false;
 List<Asset> get assets => appState.claimsState.assets;
 UserModel get user => appState.userState.user!;
 get imagesHash => localClaims
 .map((e) => e.images.fold('', (acc, e) => '$acc$e'))
 .fold('', (acc, e) => '$acc$e');
 @override
 List<Object?> get props => [
 showLoader,
 selectedTab,
 count,
 claims,
 assets,
 localClaims,
 imagesHash,
 ];
}
```

## File: lib/claims/create_claim_dialog.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/claims/redux/claims_actions.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/local_storages/shared_prefs.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
void createClaimDialog(BuildContext context, UserModel user) {
 final TextEditingController descriptionController = TextEditingController();
 final TextEditingController locationController = TextEditingController();
 showDialog(
 barrierDismissible: false,
 context: context,
 builder: (context) => StoreConnector<AppState, (bool, String)>(
 converter: (store) => (
 store.state.isConnected,
 store.state.claimsState.pickedSite ?? user.defaultSite ?? '',
 ),
 builder: (context, vm) {
 return AlertDialog(
 insetPadding: const EdgeInsets.all(10),
 title: Column(
 children: [
 Text(Txt.newClaim),
 if (user.isCo)
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Text(
 Txt.pickSite,
 style: const TextStyle(fontSize: 13),
 ),
 DropdownButton(
 value: vm.$2,
 items: readSites()
 .map((site) => DropdownMenuItem(
 value: site.value,
 child: Text(
 '${site.value} ${site.description}',
 style: const TextStyle(fontSize: 13),
 )))
 .toList(),
 onChanged: (site) {
 context.store
 .dispatch(PickedSiteAction(site ?? ''));
 }),
 ],
 ),
 ],
 ),
 content: CreateClaimContent(
 descriptionController: descriptionController,
 locationController: locationController,
 ),
 actions: [
 TextButton(
 child: Text(Txt.cancel),
 onPressed: () {
 context.pop();
 },
 ),
 TextButton(
 child: Text(
 Txt.saveNewClaim,
 style: TextStyle(color: !vm.$1 ? Colors.red : null),
 ),
 onPressed: () {
 if (locationController.text.length < 3) {
 infoDialog(context, message: Txt.enterLocation);
 return;
 } else if (descriptionController.text.length < 3) {
 infoDialog(context, message: Txt.enterDescription);
 return;
 }
 context.store.dispatch(createClaimAction(
 location: locationController.text.trim(),
 description: descriptionController.text.trim(),
 pickedSite: vm.$2,
 ));
 context.pop();
 },
 ),
 ],
 );
 }),
 );
}
class CreateClaimContent extends StatelessWidget {
 const CreateClaimContent(
 {super.key,
 required this.descriptionController,
 required this.locationController});
 final TextEditingController descriptionController;
 final TextEditingController locationController;
 @override
 Widget build(BuildContext context) {
 final user = context.store.state.userState.user;
 return SizedBox(
 width: MediaQuery.of(context).size.width,
 height: MediaQuery.of(context).size.height,
 child: SingleChildScrollView(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text('${Txt.from} ${user?.displayName ?? user?.loginID}'),
 gap40,
 TextField(
 decoration: InputDecoration(
 hintText: Txt.locationDescription,
 hintStyle: _hintStyle,
 border: _border,
 ),
 controller: locationController,
 keyboardType: TextInputType.multiline,
 maxLines: null,
 minLines: 2,
 maxLength: 250,
 ),
 gap20,
 TextField(
 decoration: InputDecoration(
 hintText: Txt.claimText,
 hintStyle: _hintStyle,
 border: _border,
 ),
 controller: descriptionController,
 keyboardType: TextInputType.multiline,
 maxLines: null,
 minLines: 3,
 maxLength: 500,
 ),
 ],
 ),
 ),
 );
 }
}
const _hintStyle = TextStyle(color: gray, fontSize: 12);
final _border = OutlineInputBorder(
 borderSide: const BorderSide(color: primary, width: 4),
 borderRadius: BorderRadius.circular(12),
);
```

## File: lib/claims/create_claim_view.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/claims/claims_list.dart';
import 'package:inspector_tps/claims/create_claim_dialog.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import '../core/txt.dart';
class CreateClaimView extends StatelessWidget {
 const CreateClaimView(
 {super.key,
 required this.localClaims,
 required this.sentClaims,
 required this.user});
 final List<Sr> localClaims;
 final List<Sr> sentClaims;
 final UserModel user;
 @override
 Widget build(BuildContext context) {
 return Scaffold(
 backgroundColor: Colors.transparent,
 floatingActionButton: FloatingActionButton(
 backgroundColor: primary,
 onPressed: () {
 createClaimDialog(context, user);
 },
 child: const Icon(
 Icons.add,
 size: 50,
 ),
 ),
 body: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 mainAxisAlignment: MainAxisAlignment.start,
 children: [
 gap10,
 if (localClaims.isNotEmpty) ...[
 Padding(
 padding: const EdgeInsets.only(left: 5.0),
 child: Text(Txt.savedClaims,
 style: const TextStyle(
 fontSize: 12, fontWeight: FontWeight.bold)),
 ),
 Expanded(
 child: ClaimsList(
 srList: localClaims,
 user: user,
 ),
 ),
 ],
 if (sentClaims.isNotEmpty) ...[
 Padding(
 padding: const EdgeInsets.only(left: 5.0),
 child: Text(Txt.sentClaims,
 style: const TextStyle(
 fontSize: 12, fontWeight: FontWeight.bold)),
 ),
 Expanded(
 child: ClaimsList(
 srList: sentClaims,
 user: user,
 ),
 ),
 ],
 ],
 ),
 );
 }
}
```

## File: lib/claims/no_rz_widget.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class NoRzWidget extends StatelessWidget {
 const NoRzWidget({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 return Center(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.center,
 children: [
 const Spacer(),
 Text(vm.shouldDownload ? Txt.noRz : Txt.noRzForShift,
 textAlign: TextAlign.center,
 style: const TextStyle(fontSize: 25)),
 const SizedBox(height: 150),
 if (vm.shouldDownload)
 ElevatedButton(
 style: ElevatedButton.styleFrom(backgroundColor: primary),
 onPressed: () {
 context.store
 .dispatch(downloadRzListAction());
 },
 child: Text(Txt.downloadRz)),
 const Spacer(),
 ],
 ),
 );
 });
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 List<WorkTaskMobile> get rzList => appState.claimsState.rzList ?? [];
 RzFilter get filter => appState.claimsState.rzFilter;
 bool get shouldDownload => rzList.isEmpty && filter == RzFilter.all;
 @override
 List<Object?> get props => [rzList, filter];
}
```

## File: lib/claims/pick_asset_screen.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:flutter_typeahead/flutter_typeahead.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class PickAssetScreen extends StatelessWidget {
 const PickAssetScreen({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 onInit: (store) {
 context.store.dispatch(readAssetsFromDbAction());
 },
 builder: (context, vm) {
 return Scaffold(
 appBar: AppBar(
 title: Text('${Txt.assetsCount} ${vm.assets.length}'),
 actions: [
 IconButton(
 onPressed: () {
 context.go(AppRoute.rzDetailed.route);
 },
 icon: const Icon(Icons.close))
 ],
 ),
 body: vm.showLoader
 ? const Padding(
 padding:
 EdgeInsets.symmetric(vertical: 50.0, horizontal: 16),
 child: LoaderWithDescription(),
 )
 : vm.assets.isEmpty
 ? Center(
 child: Padding(
 padding: const EdgeInsets.all(16.0),
 child: ElevatedButton(
 onPressed: () {
 downloadAssets(context);
 },
 child: Padding(
 padding: const EdgeInsets.all(8.0),
 child: Text(
 Txt.downloadAssets,
 textAlign: TextAlign.center,
 style: const TextStyle(fontSize: 16),
 ),
 )),
 ),
 )
 : Padding(
 padding: const EdgeInsets.symmetric(
 vertical: 20.0, horizontal: 5),
 child: TypeAheadField<Asset>(
 builder: (context, controller, focusNode) {
 return TextField(
 controller: controller,
 focusNode: focusNode,
 autofocus: true,
 decoration: InputDecoration(
 border: const OutlineInputBorder(),
 labelText: Txt.searchAsset,
 ));
 },
 itemBuilder: (context, asset) {
 final description = asset.description ?? '';
 final num = asset.assetnum ?? '';
 final location = asset.locationDescription ?? '';
 final equipment =
 asset.classstructureDescription ?? '';
 return InkWell(
 onTap: () {
 context.store.dispatch(updateRzAssetnumAction(
 wonum: vm.selectedRz.wonum!,
 assetnum: asset.assetnum!));
 context.go(AppRoute.rzDetailed.route);
 },
 child: ListTile(
 title: Text('$num $description'),
 subtitle: Text('$location $equipment'),
 ),
 );
 },
 onSelected: (asset) {},
 suggestionsCallback: (pattern) =>
 suggestionsCallback(pattern, vm.assets),
 ),
 ),
 );
 });
 }
 Future<List<Asset>> suggestionsCallback(
 String pattern, List<Asset> assets) async =>
 Future<List<Asset>>.delayed(
 const Duration(milliseconds: 300),
 () => assets.where((asset) {
 final description = asset.description ?? '';
 final num = asset.assetnum ?? '';
 final location = asset.locationDescription ?? '';
 final equipment = asset.classstructureDescription ?? '';
 final p = pattern.trim().toLowerCase();
 return '$num $description $location $equipment'
 .toLowerCase()
 .contains(p);
 }).toList(),
 );
}
class _VM extends Equatable {
 final AppState state;
 const _VM(this.state);
 List<Asset> get assets => state.claimsState.assets;
 bool get showLoader => state.showLoader;
 WorkTaskMobile get selectedRz => state.claimsState.selectedRz!;
 @override
 List<Object?> get props => [assets, showLoader];
}
```

## File: lib/claims/redux/claims_actions.dart
```dart
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
sealed class ClaimsAction {}
class SelectedRzAction extends ClaimsAction {
 final WorkTaskMobile rz;
 SelectedRzAction(this.rz);
}
class SetRzListAction extends ClaimsAction {
 final List<WorkTaskMobile>? rzList;
 SetRzListAction(this.rzList);
}
class SetAssetsAction extends ClaimsAction {
 final List<Asset>? assets;
 SetAssetsAction(this.assets);
}
class SetRzFilterAction extends ClaimsAction {
 final RzFilter filter;
 SetRzFilterAction(this.filter);
}
class SetSrListAction extends ClaimsAction {
 final List<Sr>? srList;
 SetSrListAction(this.srList);
}
class SetClaimsTabAction extends ClaimsAction {
 final ClaimsTab tab;
 SetClaimsTabAction(this.tab);
}
class PickedSiteAction extends ClaimsAction {
 final String site;
 PickedSiteAction(this.site);
}
class SetRzTabAction extends ClaimsAction {
 final RzTab tab;
 SetRzTabAction(this.tab);
}
class ClearSelectedAssetAction extends ClaimsAction {}
class ClearClaimsStateAction extends ClaimsAction {}
```

## File: lib/claims/redux/claims_reducer.dart
```dart
import 'package:inspector_tps/claims/redux/claims_actions.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
ClaimsState claimsReducer(ClaimsState state, dynamic action) {
 if (action is SetRzListAction) {
 return state.copyWith(rzList: action.rzList);
 } else if (action is SelectedRzAction) {
 return state.copyWith(selectedRz: action.rz);
 } else if (action is ClearClaimsStateAction) {
 return ClaimsState.initial();
 } else if (action is SetRzFilterAction) {
 return state.copyWith(rzFilter: action.filter);
 } else if (action is SetSrListAction) {
 return state.copyWith(srList: action.srList);
 } else if (action is SetClaimsTabAction) {
 return state.copyWith(selectedTab: action.tab);
 } else if (action is SetRzTabAction) {
 return state.copyWith(selectedRzTab: action.tab);
 } else if (action is SetAssetsAction) {
 return state.copyWith(assets: action.assets);
 } else if (action is PickedSiteAction) {
 return state.copyWith(pickedSite: action.site);
 } else if (action is ClearSelectedAssetAction) {
 return state.copyWith(clearSelectedAsset: true);
 }
 return state;
}
```

## File: lib/claims/redux/claims_state.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
enum RzFilter {
 all,
}
enum ClaimsTab {
 rzList(0, 'СПИСОК РЗ'),
 createClaim(1, 'СОЗДАТЬ ЗАЯВКУ');
 const ClaimsTab(this.i, this.value);
 final String value;
 final int i;
}
enum RzTab {
 info(0, 'Информация'),
 comments(1, 'Комментарии');
 const RzTab(this.i, this.value);
 final String value;
 final int i;
}
@immutable
class ClaimsState {
 final List<WorkTaskMobile>? rzList;
 final WorkTaskMobile? selectedRz;
 final RzFilter rzFilter;
 final ClaimsTab selectedTab;
 final RzTab selectedRzTab;
 final List<Sr>? srList;
 final List<Asset> assets;
 final String? pickedSite;
 const ClaimsState._({
 this.rzList,
 this.srList,
 this.selectedRz,
 this.selectedTab = ClaimsTab.rzList,
 this.selectedRzTab = RzTab.info,
 this.rzFilter = RzFilter.all,
 this.pickedSite,
 this.assets = const [],
 });
 factory ClaimsState.initial() => const ClaimsState._();
 ClaimsState copyWith({
 List<WorkTaskMobile>? rzList,
 List<Sr>? srList,
 WorkTaskMobile? selectedRz,
 RzFilter? rzFilter,
 ClaimsTab? selectedTab,
 RzTab? selectedRzTab,
 List<Asset>? assets,
 bool clearSelectedAsset = false,
 String? pickedSite,
 }) {
 return ClaimsState._(
 rzList: rzList ?? this.rzList,
 srList: srList ?? this.srList,
 selectedRz: selectedRz ?? this.selectedRz,
 rzFilter: rzFilter ?? this.rzFilter,
 selectedTab: selectedTab ?? this.selectedTab,
 selectedRzTab: selectedRzTab ?? this.selectedRzTab,
 assets: assets ?? this.assets,
 pickedSite: pickedSite ?? this.pickedSite,
 );
 }
}
```

## File: lib/claims/redux/claims_thunk.dart
```dart
import 'dart:math';
import 'package:flutter/cupertino.dart';
import 'package:inspector_tps/claims/redux/claims_actions.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/core/api/endpoints.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/local_storages/shared_prefs.dart';
import 'package:inspector_tps/data/maximo_repository.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';
ThunkAction<AppState> downloadRzListAction() => (store) async {
 if (!store.state.isConnected) {
 return;
 }
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final rzListResponse = await sl<MaximoRepository>().downloadRzList();
 await insertRz(rzListResponse?.member ?? []);
 store.dispatch(readRzListFromDbAction());
 } catch (err) {
 debugPrint('download ppr thunk error: $err');
 } finally {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> downloadAssetsCatalogAction() => (store) async {
 if (!store.state.isConnected) {
 return;
 }
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final assetsJson =
 await sl<MaximoRepository>().downloadAssetsCatalog() ?? [];
 final assets = <Asset>[];
 for (var ass in assetsJson) {
 final asset = Asset.fromJson(ass);
 try {
 final location = (ass['locations'] as List).first['description'];
 asset.locationDescription = location;
 } catch (err) {
 debugPrint(
 'no location for asset: ${asset.assetnum} ${asset.description}');
 }
 try {
 final equipment =
 (ass['classstructure'] as List).first['description'];
 asset.classstructureDescription = equipment;
 } catch (err) {
 debugPrint(
 'no equipment for asset: ${asset.assetnum} ${asset.description}');
 }
 assets.add(asset);
 }
 await insertAssets(assets);
 store.dispatch(SetAssetsAction(assets));
 } catch (err) {
 debugPrint('download assets thunk error: $err');
 } finally {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> downloadSitesAction() => (store) async {
 if (!store.state.isConnected) {
 return;
 }
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final sites = await sl<MaximoRepository>().downloadSites();
 if (sites == null) {
 throw 'no sites downloaded';
 }
 saveSites(sites);
 final savedSites = readSites();
 print('saved sites: $savedSites');
 } catch (err) {
 debugPrint('download sites thunk error: $err');
 } finally {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> readRzListFromDbAction() => (store) async {
 final filter = store.state.claimsState.rzFilter;
 store.dispatch(ShowLoader());
 final List<WorkTaskMobile> savedRzList;
 switch (filter) {
 case RzFilter.all:
 savedRzList = await readAllRz();
 break;
 default:
 savedRzList = await readAllRz();
 break;
 }
 store.dispatch(SetRzListAction(savedRzList));
 store.dispatch(HideLoader());
 };
ThunkAction<AppState> readAssetsFromDbAction() => (store) async {
 store.dispatch(ShowLoader());
 final List<Asset> assets = await readAssets();
 store.dispatch(SetAssetsAction(assets));
 store.dispatch(HideLoader());
 };
ThunkAction<AppState> addCommentToRzAction(
 {required String wonum, required String comment}) =>
 (store) async {
 await addCommentToWorklogTable(wonum, comment);
 store.dispatch(readSelectedRzFromDbAction(wonum));
 };
ThunkAction<AppState> readSelectedRzFromDbAction(String wonum) =>
 (store) async {
 final rz = await readRzByWonum(wonum);
 store.dispatch(SelectedRzAction(rz));
 };
ThunkAction<AppState> deleteRzCommentAction(
 {required String wonum, required String comment}) =>
 (store) async {
 await deleteComment(wonum, comment);
 store.dispatch(readSelectedRzFromDbAction(wonum));
 };
ThunkAction<AppState> updateRzAssetnumAction({
 required String wonum,
 required String assetnum,
}) =>
 (store) async {
 await updateRzAssetnum(wonum: wonum, assetnum: assetnum);
 store.dispatch(readSelectedRzFromDbAction(wonum));
 };
ThunkAction<AppState> rzProblemSolvedAction(
 WorkTaskMobile rz, String? href, String? doclinks,
 {required bool solved, required String assetnum}) =>
 (store) async {
 final wonum = rz.wonum!;
 store.dispatch(ShowLoader());
 if (!store.state.isConnected) {
 await updateRzOfflineScript(
 wonum: wonum,
 script: solved ? rzProblemSolvedScript : rzProblemUnSolvedScript);
 finallyRz(store, wonum);
 return;
 }
 try {
 await userController.checkAuthorization();
 await sendComments(wonum, href);
 await uploadWtmImages(wonum, doclinks);
 final assetnumUploaded = await sl<MaximoRepository>()
 .uploadAssetnumToWorkTaskMobile(href!, assetnum);
 if (!assetnumUploaded) throw 'cannot upload assetnum';
 final success = await sl<MaximoRepository>().runScript(wonum,
 script: solved ? rzProblemSolvedScript : rzProblemUnSolvedScript,
 description: 'rzProblemSolvedAction: $solved script');
 if (success) {
 await downloadAndInsertUpdatedRzStatus(wonum);
 await deleteCommentsByWonum(wonum);
 }
 } catch (err) {
 debugPrint('rzProblemSolvedAction error: $err');
 } finally {
 finallyRz(store, wonum);
 }
 };
ThunkAction<AppState> sendLocallyProcessedRzs() => (store) async {
 store.dispatch(ShowLoader());
 final rzs = await readAllReadyRzs();
 await userController.checkAuthorization();
 try {
 for (var rz in rzs) {
 await sendComments(rz.wonum!, rz.href!);
 await uploadWtmImages(rz.wonum!, rz.doclinks!.href!);
 final assetnumUploaded = await sl<MaximoRepository>()
 .uploadAssetnumToWorkTaskMobile(rz.href!, rz.assetnum!);
 if (!assetnumUploaded) throw 'cannot upload assetnum';
 final success = await sl<MaximoRepository>().runScript(rz.wonum!,
 script: rz.offlineScript!,
 description:
 'rzProblemSolvedAction: ${rz.offlineScript!} script');
 if (success) {
 await downloadAndInsertUpdatedRzStatus(rz.wonum!);
 await deleteCommentsByWonum(rz.wonum!);
 await removeRzOfflineScript(wonum: rz.wonum!);
 }
 }
 } catch (err) {
 debugPrint('rzProblemSolvedAction error: $err');
 } finally {
 finallyRz(store, null);
 }
 };
ThunkAction<AppState> deleteAllRzAction(List<String> wonums) => (store) async {
 await deleteAllRz(wonums);
 store.dispatch(ClearClaimsStateAction());
 await store.dispatch(readRzListFromDbAction());
 };
ThunkAction<AppState> deletePreAcceptedRzAction() => (store) async {
 final delWonums = await readPreAcceptedRzWonums();
 print(delWonums);
 for (final w in delWonums) {
 await deleteRz(w);
 }
 await store.dispatch(readRzListFromDbAction());
 };
Future<void> downloadAndInsertUpdatedRz(String wonum) async {
 final repo = sl<MaximoRepository>();
 final rzResponse = await repo.downloadWtmByWonum(wonum);
 final updatedRz = rzResponse?.member?.first;
 debugPrint('upd rz: $updatedRz');
 if (updatedRz != null && updatedRz.wonum != null) {
 await deleteRz(updatedRz.wonum!);
 await insertRz([updatedRz]);
 }
}
Future<void> downloadAndInsertUpdatedRzStatus(String wonum) async {
 final repo = sl<MaximoRepository>();
 final rzResponse = await repo.downloadWtmByWonum(wonum);
 final updatedRz = rzResponse?.member?.first;
 final status = updatedRz?.status;
 debugPrint('updated rz status: $status');
 if (updatedRz != null &&
 updatedRz.wonum != null &&
 updatedRz.status != null) {
 await updateRzStatus(
 wonum: wonum,
 status: updatedRz.status!,
 statusDescription: updatedRz.statusDescription ?? '');
 }
}
void finallyRz(Store<AppState> store, String? wonum) {
 if (wonum != null) {
 store.dispatch(readSelectedRzFromDbAction(wonum));
 }
 store.dispatch(readRzListFromDbAction());
 store.dispatch(HideLoader());
}
ThunkAction<AppState> createClaimAction(
 {required String location,
 required String description,
 required String? pickedSite,
 bool finallyHideLoader = true}) =>
 (store) async {
 store.dispatch(ShowLoader());
 final sr = Sr(
 changedate: DateTime.now().millisecondsSinceEpoch.toString(),
 locdesc: location,
 siteid: pickedSite,
 description: description);
 await insertSr(sr);
 store.dispatch(readSrListFromDbAction());
 store.dispatch(HideLoader());
 };
ThunkAction<AppState> sendClaimToMaximoAction({
 required Sr savedSr,
 bool finallyHideLoader = true,
 required UserModel user,
}) =>
 (store) async {
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final sr = await sl<MaximoRepository>().createSr(
 location: savedSr.locdesc ?? '',
 siteId: savedSr.siteid ?? user.defaultSite ?? '',
 description: savedSr.description ?? 'n/a');
 if (sr != null) {
 final doclink = '${sr.href}${Endpoints.doclinks}'
 .replaceFirst('mxsr', 'ilcmobsr');
 debugPrint('sr doclink: $doclink');
 await uploadWtmImages(savedSr.changedate ?? '', doclink);
 await deleteSrByDescriptions(sr: sr);
 await insertSr(sr);
 store.dispatch(readSrListFromDbAction());
 }
 } catch (err) {
 debugPrint('thunk create sr error: $err');
 } finally {
 if (finallyHideLoader) {
 store.dispatch(HideLoader());
 }
 }
 store.dispatch(readSrListFromDbAction());
 store.dispatch(HideLoader());
 };
sendAllSavedSr(BuildContext context, UserModel user) async {
 final List<Sr> savedSr = await readSavedSr();
 for (final sr in savedSr) {
 final action = sendClaimToMaximoAction(savedSr: sr, user: user);
 if (context.mounted) {
 context.store.dispatch(action);
 }
 }
}
ThunkAction<AppState> readSrListFromDbAction() => (store) async {
 store.dispatch(ShowLoader());
 final srList = await readAllSr();
 store.dispatch(SetSrListAction(srList));
 store.dispatch(HideLoader());
 };
ThunkAction<AppState> readSrListAndAssetsFromDbAction() => (store) async {
 store.dispatch(ShowLoader());
 final srList = await readAllSr();
 store.dispatch(SetSrListAction(srList));
 final assets = await readAssets();
 store.dispatch(SetAssetsAction(assets));
 store.dispatch(HideLoader());
 };
ThunkAction<AppState> deleteSrAction(Sr sr) => (store) async {
 store.dispatch(ShowLoader());
 await deleteSr(sr: sr);
 store.dispatch(readSrListFromDbAction());
 store.dispatch(HideLoader());
 };
```

## File: lib/claims/rz_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/core/widgets/card_divider.dart';
import 'package:inspector_tps/core/widgets/unsaved_icon_button.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class RzCard extends StatelessWidget {
 const RzCard({super.key, required this.rz, this.showReady = false});
 final WorkTaskMobile rz;
 final bool showReady;
 @override
 Widget build(BuildContext context) {
 final bool isOutdated = outdated(rz.targcompdate ?? '');
 final textTheme = Theme.of(context).textTheme;
 final textStyle = textTheme.bodyMedium?.copyWith(color: primary);
 final dateStyle = textTheme.labelMedium
 ?.copyWith(fontWeight: FontWeight.bold, color: primary);
 final headerStyle = dateStyle?.copyWith(fontSize: 9);
 Widget dateRow = Container(
 color: isOutdated ? accent.withOpacity(0.5) : Colors.transparent,
 child: Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Row(
 children: [
 Text(Txt.claimFrom, style: dateStyle),
 Text(dateFromIso(rz.reportDate ?? ''), style: dateStyle),
 ],
 ),
 Row(
 children: [
 Text(Txt.finishUntil, style: dateStyle),
 Text(dateTimeFromIso(rz.targcompdate ?? ''), style: dateStyle),
 ],
 ),
 ],
 ),
 );
 Widget header = Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Row(
 children: [
 Text(rz.siteid ?? '', style: dateStyle),
 span5,
 Text(rz.wonum ?? '', style: dateStyle),
 ],
 ),
 Text(rz.worktype ?? '', style: headerStyle),
 Row(
 children: [
 if (rz.offlineScript != null) const UnsavedIconButton(),
 Text(
 rz.statusDescription ?? '',
 style: headerStyle?.copyWith(
 color: primary,
 ),
 ),
 ],
 ),
 ],
 );
 return Card(
 elevation: 1,
 color: rz.status == statusPreApproved
 ? gray
 : rz.status == statusDefecting
 ? redBg
 : white,
 child: Padding(
 padding: const EdgeInsets.all(8.0),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 header,
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Text(rz.priority ?? '',
 style: headerStyle?.copyWith(color: accent)),
 Text(rz.displayName ?? '',
 maxLines: 1,
 overflow: TextOverflow.ellipsis,
 style: headerStyle?.copyWith(color: accent)),
 ],
 ),
 gap10,
 Text(
 rz.description ?? '',
 style: textStyle,
 ),
 gap10,
 Text(
 rz.asset?.description ?? '',
 style: textStyle,
 ),
 gap10,
 const CardDivider(),
 gap10,
 dateRow,
 ],
 ),
 ),
 );
 }
}
```

## File: lib/claims/rz_comments_view.dart
```dart
import 'dart:math';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/data/models/worklog/worklog.dart';
import 'package:inspector_tps/ppr/view/detailed/add_comment_button.dart';
import 'package:inspector_tps/ppr/view/detailed/comment_card.dart';
class RzCommentsView extends StatelessWidget {
 const RzCommentsView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 return Expanded(
 child: Column(
 children: [
 AddCommentButton(
 text: Txt.addRzComment,
 onTap: () => _addComment(context, vm.selectedRz),
 ),
 gap10,
 if (vm.freshComments.isNotEmpty)
 Text(
 Txt.fresh,
 style: const TextStyle(fontWeight: FontWeight.bold),
 ),
 gap10,
 if (vm.freshComments.isNotEmpty)
 SizedBox(
 height: min(vm.freshComments.length * 70, 250),
 child: ListView.builder(
 itemCount: vm.freshComments.length,
 itemBuilder: (context, index) {
 final comment = vm.freshComments[index];
 return CommentCard(
 worklog: comment,
 href: vm.selectedRz.href,
 doclinks: vm.selectedRz.doclinks?.href,
 isPpr: false,
 );
 })),
 gap10,
 if (vm.downloadedComments.isNotEmpty)
 Text(
 Txt.downloaded,
 style: const TextStyle(fontWeight: FontWeight.bold),
 ),
 gap10,
 SizedBox(
 height: min(vm.downloadedComments.length * 60, 250),
 child: ListView.builder(
 itemCount: vm.downloadedComments.length,
 itemBuilder: (context, index) {
 final comment = vm.downloadedComments[index];
 return CommentCard(worklog: comment);
 })),
 ],
 ),
 );
 });
 }
 void _addComment(BuildContext context, WorkTaskMobile rz) {
 addRzCommentDialog(context, rz);
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 WorkTaskMobile get selectedRz => appState.claimsState.selectedRz!;
 List<Worklog> get comments => selectedRz.worklog ?? [];
 List<String> get images => selectedRz.images;
 List<Worklog> get downloadedComments =>
 comments.where((c) => !c.fresh).toList();
 List<Worklog> get freshComments => comments.where((c) => c.fresh).toList();
 @override
 List<Object?> get props => [
 downloadedComments,
 freshComments,
 ];
}
```

## File: lib/claims/rz_detailed_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/claims/redux/claims_actions.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/claims/rz_comments_view.dart';
import 'package:inspector_tps/claims/rz_info_view.dart';
import 'package:inspector_tps/claims/rz_tabs_switcher.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class RzDetailedView extends StatelessWidget {
 const RzDetailedView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 return Scaffold(
 backgroundColor: positive.withOpacity(0.05),
 appBar: AppBar(
 title: Text('${Txt.rz}: ${vm.selectedRz.wonum ?? ''}'),
 leading: InkWell(
 onTap: () => _handleBack(context, vm),
 child: const Icon(
 Icons.arrow_back,
 color: Colors.white,
 ),
 ),
 actions: [
 if (vm.images.length < 7)
 IconButton(
 onPressed: () {
 attachPhoto(context,
 checklistwoid: null,
 wonum: vm.selectedRz.wonum!,
 mode: CameraMode.rz);
 },
 icon: const Icon(Icons.camera_alt_outlined)),
 ],
 ),
 body: vm.showLoader
 ? const Column(
 children: [
 Spacer(),
 LoaderWithDescription(),
 Spacer(),
 ],
 )
 : Padding(
 padding: const EdgeInsets.symmetric(horizontal: 10.0),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 gap10,
 const RzTabsSwitcher(),
 gap10,
 if (vm.selectedTab == RzTab.info) const RzInfoView(),
 if (vm.selectedTab == RzTab.comments)
 const RzCommentsView(),
 ],
 ),
 ),
 );
 });
 }
 void _handleBack(BuildContext context, _VM vm) {
 context.store.dispatch(ClearSelectedAssetAction());
 context.go(AppRoute.claims.route);
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 RzTab get selectedTab => appState.claimsState.selectedRzTab;
 WorkTaskMobile get selectedRz => appState.claimsState.selectedRz!;
 bool get showLoader => appState.showLoader;
 bool get isConnected => appState.isConnected;
 List<String> get images => selectedRz.images;
 @override
 List<Object?> get props => [
 showLoader,
 selectedTab,
 isConnected,
 selectedRz,
 ];
}
```

## File: lib/claims/rz_info_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/audit/view/checklist/images_row.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/core/widgets/unsaved_icon_button.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/view/detailed/info_card.dart';
class RzInfoView extends StatelessWidget {
 const RzInfoView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 final bool assigned = vm.status == statusAssigned;
 return Expanded(
 child: SingleChildScrollView(
 child: Column(
 mainAxisSize: MainAxisSize.min,
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 gap10,
 Row(
 children: [
 Expanded(
 child: InfoCard(
 title: Txt.statusCond,
 subTitle: vm.statusDescription,
 color: assigned ? positive : primary),
 ),
 span20,
 if (vm.savedOffline) const UnsavedIconButton(),
 ],
 ),
 gap10,
 Padding(
 padding: const EdgeInsets.symmetric(horizontal: 10.0),
 child: Row(
 children: [
 const Icon(Icons.person),
 span10,
 Expanded(
 child: Text(vm.selectedRz.displayName ??
 vm.selectedRz.owner ??
 ''),
 ),
 ],
 ),
 ),
 gap10,
 InfoCard(
 title: Txt.fromWho,
 subTitle: vm.fromWho,
 color: assigned ? positive : primary),
 gap10,
 InfoCard(
 title: Txt.priority,
 subTitle: vm.priority,
 color: assigned ? positive : primary),
 gap10,
 Row(
 children: [
 Expanded(
 child: InfoCard(
 title: Txt.claimFrom, subTitle: vm.reportDate)),
 span5,
 Expanded(
 child: InfoCard(
 title: Txt.finishUntil, subTitle: vm.finish)),
 ],
 ),
 gap10,
 InfoCard(
 title: Txt.systemCategory,
 subTitle: vm.systemCategory,
 color: assigned ? positive : primary),
 gap10,
 Text(
 Txt.claim,
 ),
 Text(
 vm.description,
 style: const TextStyle(
 fontWeight: FontWeight.bold, color: accent),
 textAlign: TextAlign.left,
 ),
 gap10,
 if (vm.savedAsset != null) ...[
 Text(Txt.asset),
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Expanded(
 child: Text(
 vm.savedAsset.toString(),
 style: const TextStyle(
 color: positive,
 fontSize: 12,
 fontWeight: FontWeight.bold),
 ),
 ),
 IconButton(
 style: ElevatedButton.styleFrom(
 backgroundColor: primary, // background
 ),
 onPressed: () {
 context.go(AppRoute.pickAssetRoute.route);
 },
 icon: const Icon(Icons.sync, color: primary),
 ),
 ],
 ),
 ],
 gap10,
 if (vm.showRzSolvedButtons)
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Expanded(
 child: ElevatedButton(
 onPressed: () {
 context.store.dispatch(rzProblemSolvedAction(
 vm.selectedRz,
 vm.selectedRz.href,
 vm.selectedRz.doclinks?.href,
 solved: false,
 assetnum: vm.selectedRz.assetnum!,
 ));
 },
 style: ElevatedButton.styleFrom(
 shape: const StadiumBorder(),
 backgroundColor: accent),
 child: Text(Txt.unSolved)),
 ),
 span20,
 Expanded(
 child: ElevatedButton(
 onPressed: () {
 context.store.dispatch(rzProblemSolvedAction(
 vm.selectedRz,
 vm.selectedRz.href,
 vm.selectedRz.doclinks?.href,
 solved: true,
 assetnum: vm.selectedRz.assetnum!));
 },
 style: ElevatedButton.styleFrom(
 shape: const StadiumBorder(),
 backgroundColor: positive),
 child: Text(Txt.solved)),
 ),
 ],
 ),
 if (vm.showAddCommentsButton)
 Row(
 children: [
 Expanded(
 child: ElevatedButton(
 style: ElevatedButton.styleFrom(
 backgroundColor: accent, // background
 ),
 onPressed: () {
 _addComment(context, vm.selectedRz);
 },
 child: Text(Txt.shouldAddCommentButton),
 ),
 ),
 ],
 ),
 if (vm.showPickAssetButton)
 Row(
 mainAxisAlignment: MainAxisAlignment.center,
 children: [
 ElevatedButton(
 style: ElevatedButton.styleFrom(
 backgroundColor: primary, // background
 ),
 onPressed: () {
 context.go(AppRoute.pickAssetRoute.route);
 },
 child: Text(Txt.pickAsset),
 ),
 ],
 ),
 gap10,
 ImagesRow(
 images: vm.images,
 wonum: vm.selectedRz.wonum,
 mode: CameraMode.rz,
 ),
 ],
 ),
 ),
 );
 });
 }
 void _addComment(BuildContext context, WorkTaskMobile ppr) {
 addRzCommentDialog(context, ppr);
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 WorkTaskMobile get selectedRz => appState.claimsState.selectedRz!;
 String get status => selectedRz.status ?? '';
 String get fromWho => selectedRz.fromwho ?? '';
 String get statusDescription => selectedRz.statusDescription ?? '';
 bool get savedOffline => selectedRz.offlineScript != null;
 String get priority => selectedRz.priority ?? '';
 String get systemCategory => selectedRz.ticketdesc ?? '';
 String get finish => dateTimeFromIso(selectedRz.targcompdate ?? '');
 String get reportDate => dateFromIso(selectedRz.reportDate ?? '');
 String get description => selectedRz.description ?? '';
 Asset? get savedAsset => selectedRz.asset;
 List<String> get images => selectedRz.images;
 bool get showPickAssetButton =>
 savedAsset == null && selectedRz.status == statusAssigned;
 bool get showAddCommentsButton =>
 savedAsset != null &&
 selectedRz.status == statusAssigned &&
 !hasFreshComments;
 bool get showRzSolvedButtons =>
 savedAsset != null &&
 selectedRz.status == statusAssigned &&
 hasFreshComments;
 bool get hasFreshComments =>
 (selectedRz.worklog ?? []).where((c) => c.fresh).toList().isNotEmpty;
 @override
 List<Object?> get props => [
 status,
 selectedRz,
 savedAsset,
 hasFreshComments,
 ];
}
```

## File: lib/claims/rz_list.dart
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/claims/rz_card.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class RzList extends StatelessWidget {
 const RzList({super.key, required this.rzList});
 final List<WorkTaskMobile> rzList;
 @override
 Widget build(BuildContext context) {
 return Padding(
 padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 10),
 child: Scrollbar(
 child: ListView.builder(
 itemCount: rzList.length,
 itemBuilder: (context, index) {
 final rz = rzList[index];
 return InkWell(
 child: RzCard(rz: rz),
 onTap: () {
 debugPrint(rz.toString());
 context.store.dispatch(readSelectedRzFromDbAction(rz.wonum!));
 context.go(AppRoute.rzDetailed.route);
 },
 );
 },
 ),
 ),
 );
 }
}
```

## File: lib/claims/rz_tabs_switcher.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/claims/redux/claims_actions.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
class RzTabsSwitcher extends StatelessWidget {
 const RzTabsSwitcher({super.key});
 @override
 Widget build(BuildContext context) {
 final buttonWidth = (MediaQuery.of(context).size.width - 32 - 20) / 2;
 return StoreConnector<AppState, RzTab>(
 converter: (store) => store.state.claimsState.selectedRzTab,
 builder: (context, tab) {
 return ToggleButtons(
 onPressed: (int index) {
 context.store.dispatch(SetRzTabAction(_tabs[index]));
 },
 borderRadius: const BorderRadius.all(Radius.circular(4)),
 borderWidth: 5,
 borderColor: grayMiddle,
 selectedColor: primary,
 color: primary,
 constraints: BoxConstraints(
 minHeight: 30.0,
 minWidth: buttonWidth,
 ),
 isSelected: [
 tab == RzTab.info,
 tab == RzTab.comments,
 ],
 children: [
 _getTabWidget(0, buttonWidth, tab),
 _getTabWidget(1, buttonWidth, tab),
 ],
 );
 });
 }
}
const _tabs = RzTab.values;
Widget _getTabWidget(
 int index,
 double width,
 RzTab selectedTab,
) {
 final tab = _tabs[index];
 final bool isSelected = tab == selectedTab;
 return Container(
 height: 30,
 width: width,
 color: isSelected ? Colors.white : grayMiddle,
 child: Center(
 child: Text(
 tab.value,
 style: const TextStyle(
 fontWeight: FontWeight.bold,
 fontSize: 12,
 ),
 ),
 ));
}
```

## File: lib/claims/rz_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/claims/no_rz_widget.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/claims/rz_list.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
class RzView extends StatelessWidget {
 const RzView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 distinct: true,
 onInit: (store) {
 if (store.state.claimsState.rzList?.isEmpty ?? true) {
 store.dispatch(readRzListFromDbAction());
 }
 },
 builder: (context, vm) {
 return vm.showLoader
 ? const Padding(
 padding: EdgeInsets.symmetric(vertical: 50.0, horizontal: 16),
 child: LoaderWithDescription(),
 )
 : vm.rzList.isEmpty
 ? const NoRzWidget()
 : RzList(rzList: vm.rzList);
 });
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 bool get showLoader => appState.showLoader;
 List<WorkTaskMobile> get rzList => appState.claimsState.rzList ?? [];
 bool get showRz => appState.userState.showRz;
 int get count => rzList.length;
 RzFilter get filter => appState.claimsState.rzFilter;
 String get filterName => switch (filter) {
 RzFilter.all => Txt.rzList,
 };
 @override
 List<Object?> get props => [rzList, showLoader, filter];
}
```

## File: lib/core/api/dio_interceptor.dart
```dart
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
class CustomInterceptors extends Interceptor {
 @override
 void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
 debugPrint('REQUEST[${options.method}] => PATH: ${options.path}');
 super.onRequest(options, handler);
 }
 @override
 void onResponse(Response response, ResponseInterceptorHandler handler) {
 debugPrint(
 'RESPONSE[${response.statusCode}] => PATH: ${response.requestOptions.path}');
 super.onResponse(response, handler);
 }
 @override
 Future onError(DioException err, ErrorInterceptorHandler handler) async {
 debugPrint(
 'ERROR[${err.response?.statusCode}] => PATH: ${err.requestOptions.path}');
 super.onError(err, handler);
 }
}
```

## File: lib/core/api/endpoints.dart
```dart
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/data/local_storages/shared_prefs.dart';
class Endpoints {
 static const protocol = 'https://';
 static const devHost = 'maximodev.itps.ru:7889';
 static const prodHost = 'maximo.itps.ru:7890';
 static const oslc = '/oslc';
 static const oslcOs = '$oslc/os';
 static const script = '$oslc/script';
 static const checklistWo = '/checklistwo';
 static const doclinks = '/doclinks';
 static const login = '$oslc/login';
 static const whoAmI = '$oslc/whoami';
 static const userGroups = '$oslc/os/oslcmaxuser?savedQuery=currentUser';
 static downloadAudits({String? siteId, required String workType}) =>
 '$oslc/os/work_task_mobile?'
 'oslc.select=description,worktype,wonum,targstartdate,targcompdate,'
 'doclinks,'
 'asset.description,'
 'location.description,'
 'location.olddescription,'
 'rs_week,rs_month,rs_quarter,rs_year'
 '&oslc.where=worktype in $workType '
 'and status in ["СФОРМИРОВАНО"]'
 '${siteId != null ? ' and siteid="$siteId"' : ''}';
 static Map<String, dynamic> lean = {'lean': 1};
 static String selectChecklistwo = '?oslc.select=checklistwo';
 static const createRsDefectComment = '$oslcOs/rs_defectcomment';
 static const String _selectForPpr =
 'oslc.select=description,wonum,targstartdate,targcompdate,'
 'worktype,status,worklog,siteid,'
 'asset.description,'
 'location.description,'
 'location.olddescription,'
 'doclinks,'
 'woactivity';
 static downloadPprByWonum(String wonum) => '$oslcOs/work_task_mobile?'
 'oslc.where=wonum=$wonum&$_selectForPpr';
 static downloadPpr(
 {required String? siteId,
 required String date,
 required pprStatuses}) =>
 '$oslc/os/work_task_mobile?$_selectForPpr'
 '&oslc.where=worktype in ["ТО2","ТО3","ТО4","ТО4Г"] '
 'and status in $pprStatuses '
 'and woclass="WORKORDER" '
 'and targstartdate>"$date" '
 'and targstartdate<"${theTwoDayAfterTomorrowIso()}"'
 '${siteId != null ? ' and siteid="$siteId"' : ''}';
 static const String _selectForRz =
 'oslc.select=description,wonum,targstartdate,targcompdate,asset'
 'worktype,status,siteid,sr,'
 'worklog,'
 'owner,'
 'person,'
 'doclinks';
 static downloadRzList({
 required String? siteId,
 }) =>
 '$oslc/os/work_task_mobile?$_selectForRz'
 '&oslc.where=worktype in ["ДИАГ"] '
 'and status in ["$statusAssigned"] '
 'and woclass="WORKORDER"'
 '${siteId != null ? 'and siteid="$siteId"' : ''}';
 static downloadAssetsCatalog({
 required String? siteId,
 }) =>
 '$oslc/os/IPC_MOB_ASSET?'
 'oslc.select=description,assetnum,locations,classstructure&'
 'oslc.where=siteid="$siteId" and status="OPERATING"';
 static const downloadSites = '$oslc/os/ALNDOMAIN'
 '?oslc.where=domainid="SITEWITHCO"&oslc.select=description,value';
 static const createSr = '$oslcOs/mxsr';
}
String get getHost =>
 Endpoints.protocol + (isDev() ? devHost : Endpoints.prodHost);
String get devHost => readHost() ?? Endpoints.devHost;
String get getBaseUrl => '$getHost/maxmob';
String get baseUrlOslcOs => '$getBaseUrl${Endpoints.oslc}/os';
class Header {
 static Map<String, String> contentJson = {'Content-Type': 'application/json'};
}
```

## File: lib/core/api/maximo_session.dart
```dart
import 'dart:io';
import 'package:cookie_jar/cookie_jar.dart';
import 'package:dio/dio.dart';
import 'package:dio/io.dart';
import 'package:dio_cookie_manager/dio_cookie_manager.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/core/api/dio_interceptor.dart';
import 'package:inspector_tps/core/api/endpoints.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/error/models/maximo_error_response.dart';
class MaximoSession {
 void config() {
 debugPrint('setting dio base url: $getBaseUrl');
 _dio = Dio(
 BaseOptions(
 baseUrl: getBaseUrl,
 responseType: ResponseType.json,
 queryParameters: {...Endpoints.lean},
 ),
 )..interceptors.addAll([
 CookieManager(CookieJar()),
 CustomInterceptors(),
 ]);
 (_dio.httpClientAdapter as IOHttpClientAdapter).createHttpClient = () =>
 HttpClient()
 ..badCertificateCallback =
 (X509Certificate cert, String host, int port) => true;
 }
 late Dio _dio;
 final Map<String, String> headers = {
 'Content-type': 'application/json',
 };
 void addHeaders(Map<String, String> newHeaders) {
 headers.addAll(newHeaders);
 }
 void removeHeaders(Iterable<String> keys) {
 for (var k in keys) {
 headers.remove(k);
 }
 }
 void resetCookie() {
 _dio.interceptors.clear();
 _dio.interceptors.add(CookieManager(CookieJar()));
 }
 void _somethingWentWrong() {
 appStore.dispatch(
 AppErrorAction(MaximoErrorResponse(message: Txt.somethingWentWrong)));
 }
 Future<dynamic> get(
 String url, {
 Map<String, String> headers = const {},
 bool dispatchError = true,
 }) async {
 debugPrint('get dio: ${_dio.options.baseUrl}\nheaders: $headers');
 debugPrint('get url: $url');
 try {
 final options = Options(headers: headers);
 final getResponse = await _dio.get(url, options: options);
 return getResponse;
 } on DioException catch (ex) {
 if (dispatchError) {
 final data = ex.response?.data;
 if (data == '') {
 if (ex.response?.statusCode == 401) {
 appStore.dispatch(AppErrorAction(MaximoErrorResponse(
 message: Txt.unauthorizedMessage,
 statusCode: ex.response?.statusCode.toString())));
 } else {
 _somethingWentWrong();
 }
 } else {
 debugPrint('error data: $data');
 try {
 final map = ex.response?.data?['Error'];
 appStore
 .dispatch(AppErrorAction(MaximoErrorResponse.fromJson(map)));
 } catch (err) {
 _somethingWentWrong();
 }
 }
 }
 } catch (err) {
 if (dispatchError) {
 _somethingWentWrong();
 }
 } finally {
 removeHeaders(headers.keys);
 }
 }
 Future<dynamic> post(
 String url, {
 Map<String, String> headers = const {},
 Object? data,
 }) async {
 debugPrint('post dio: ${_dio.options.baseUrl}');
 debugPrint('post url: $url');
 debugPrint('post headers: $headers');
 if (data is List<num>) {
 debugPrint('post data: length = ${data.length}');
 } else {
 debugPrint('post data: $data');
 }
 try {
 final options = Options(headers: headers);
 final response = await _dio.post(
 url,
 data: data,
 options: options,
 );
 return response;
 } on DioException catch (ex) {
 debugPrint('Dio post error: $ex');
 } finally {
 removeHeaders(headers.keys);
 }
 }
 void setHeadersForUploadingAttachment() {
 headers['Content-type'] = 'image/png';
 headers['x-document-meta'] = 'Attachments';
 }
 void setHeadersForUpdatingObject() {
 headers['x-method-override'] = 'PATCH';
 headers['properties'] = '*';
 }
 void setHeadersForUpdatingInnerObject() {
 headers['x-method-override'] = 'PATCH';
 headers['patchtype'] = 'MERGE';
 headers['properties'] = '*';
 }
 void setHeadersForUpdatingMaximoObject() {
 headers['x-method-override'] = 'PATCH';
 headers['properties'] = '*';
 }
 void setFileNameHeader(String filename) {
 headers['slug'] = filename;
 }
 void setHeadersForOrdinalRequests() {
 headers['Content-type'] = 'application/json';
 headers.remove('slug');
 headers.remove('x-document-meta');
 headers.remove('x-method-override');
 headers.remove('patchtype');
 headers.remove('properties');
 }
}
```

## File: lib/core/camera/camera_screen.dart
```dart
import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:path_provider/path_provider.dart';
enum CameraMode {
 checklist,
 ppr,
 rz,
 claim,
}
class CameraScreen extends StatefulWidget {
 const CameraScreen({
 super.key,
 required this.wonum,
 required this.checklistWoId,
 required this.mode,
 });
 final String wonum;
 final int? checklistWoId;
 final CameraMode mode;
 @override
 CameraScreenState createState() => CameraScreenState();
}
class CameraScreenState extends State<CameraScreen> {
 late CameraController _controller;
 late Future<void> _initializeControllerFuture;
 double _zoom = 1.0;
 double _scaleFactor = 1.0;
 double _maxScale = 10;
 double _maxCamScale = 1.0;
 @override
 void initState() {
 super.initState();
 _initializeControllerFuture = initCamera();
 }
 Future<void> initCamera() async {
 _controller = CameraController(
 appCamera,
 ResolutionPreset.medium,
 imageFormatGroup: ImageFormatGroup.yuv420,
 );
 await _controller.initialize();
 _maxCamScale = await _controller.getMaxZoomLevel();
 _maxScale = _maxCamScale > _maxScale ? _maxScale : _maxCamScale;
 }
 @override
 void dispose() {
 _controller.dispose();
 super.dispose();
 }
 @override
 Widget build(BuildContext context) {
 return Scaffold(
 appBar: AppBar(title: Text(Txt.takeAPicture)),
 body: FutureBuilder<void>(
 future: _initializeControllerFuture,
 builder: (context, snapshot) {
 if (snapshot.connectionState == ConnectionState.done) {
 return GestureDetector(
 behavior: HitTestBehavior.translucent,
 onScaleStart: (details) {
 _zoom = _scaleFactor;
 },
 onScaleUpdate: (details) {
 _scaleFactor = _zoom * details.scale;
 if (_scaleFactor <= _maxScale) {
 _controller.setZoomLevel(_scaleFactor);
 }
 },
 child: CameraPreview(_controller),
 );
 } else {
 return const Center(child: CircularProgressIndicator());
 }
 },
 ),
 floatingActionButton: FloatingActionButton(
 heroTag: 'camera',
 child: const Icon(Icons.camera_alt),
 onPressed: () async {
 await takeAndSavePhoto(context,
 controller: _controller,
 wonum: widget.wonum,
 id: widget.checklistWoId,
 mode: widget.mode);
 },
 ),
 );
 }
}
Future<void> takeAndSavePhoto(
 BuildContext context, {
 required CameraController controller,
 required String wonum,
 required int? id,
 required CameraMode mode,
}) async {
 try {
 final XFile image = await controller.takePicture();
 final imageFile = File(image.path);
 final timeStamp = DateTime.now().millisecondsSinceEpoch;
 final fileFormat = imageFile.path.split('.').last;
 final appDocumentsDir = await getApplicationDocumentsDirectory();
 final dirPath = appDocumentsDir.path;
 final separator = Platform.pathSeparator;
 final dir = await Directory(
 '$dirPath$separator$wonum${id != null ? '$separator$id' : ''}')
 .create(recursive: true);
 final imagePath = '${dir.path}$separator$timeStamp.$fileFormat';
 await image.saveTo(imagePath);
 if (image.path.isNotEmpty) {
 if (id != null) {
 await insertChlwoImagePath(
 checklistwoid: id, wonum: wonum, path: imagePath);
 } else {
 await insertWtmImagePath(wonum: wonum, path: imagePath);
 }
 }
 if (!context.mounted) return;
 switch (mode) {
 case CameraMode.checklist:
 context.store
 .dispatch(findAndUpdateWoInLevels(checklistwoid: id ?? -1));
 break;
 case CameraMode.ppr:
 context.store.dispatch(readSelectedPprFromDbAction(wonum));
 break;
 case CameraMode.rz:
 context.store.dispatch(readSelectedRzFromDbAction(wonum));
 break;
 case CameraMode.claim:
 context.store.dispatch(readSrListFromDbAction());
 break;
 }
 context.pop();
 } catch (e) {
 debugPrint(e.toString());
 }
}
```

## File: lib/core/change_contour_dialog.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/core/api/maximo_session.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/local_storages/shared_prefs.dart';
void changeContourDialog(BuildContext context) {
 showDialog(
 context: context,
 builder: (context) => StoreConnector<AppState, bool>(
 converter: (store) => store.state.isDev,
 builder: (context, isDev) {
 return AlertDialog(
 title: Text(Txt.changeContourDialogTitle),
 content: ChangeContourDialogContent(isDev: isDev),
 actions: [
 TextButton(
 onPressed: () {
 saveDev(!isDev);
 context.store.dispatch(IsDevAction(!isDev));
 sl<MaximoSession>().config();
 },
 child: Text(
 isDev ? Txt.setProd : Txt.setDev,
 ),
 ),
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.ok)),
 ],
 );
 }),
 );
}
class ChangeContourDialogContent extends StatefulWidget {
 const ChangeContourDialogContent({super.key, required this.isDev});
 final bool isDev;
 @override
 State<ChangeContourDialogContent> createState() =>
 _ChangeContourDialogContentState();
}
class _ChangeContourDialogContentState
 extends State<ChangeContourDialogContent> {
 final TextEditingController controller =
 TextEditingController(text: readHost());
 @override
 void dispose() {
 controller.dispose();
 super.dispose();
 }
 @override
 Widget build(BuildContext context) {
 return Column(
 children: [
 Text(changeContourDialogDescription(widget.isDev)),
 if (widget.isDev) ...[
 TextField(
 controller: controller,
 ),
 TextButton(
 onPressed: () {
 saveHost(controller.text.trim());
 setState(() {});
 sl<MaximoSession>().config();
 },
 child: Text(
 Txt.changeAddress,
 style: const TextStyle(color: Colors.red),
 )),
 ],
 ],
 );
 }
}
```

## File: lib/core/colors.dart
```dart
import 'dart:ui';
const primary = Color(0xff283287);
const accent = Color(0xffe84f40);
const positive = Color(0xff009000);
const gray = Color(0xffa9a9a9);
const grayMiddle = Color(0xffd9d9d9);
const white = Color(0xffffffff);
const bg = Color(0xfff5f5f5);
const redBg = Color(0xffffd6d1);
```

## File: lib/core/constants.dart
```dart
import 'package:flutter/material.dart';
const bdd = 'BDD';
const hoemp = 'HOEMP'; // CO
const dutyEngGroup = 'duty_eng';
const ceew = 'СEEW';
const statusApproved = 'УТВЕРЖДЕНО';
const statusAssigned = 'НАЗНАЧЕНО';
const statusRejected = 'ОТКЛОНЕНО';
const statusCompleted = 'ЗАВЕРШ';
const statusFullyCompleted = 'ЗАВЕРШЕНО';
const statusPreApproved = 'ПРЕДВ. ПРИНЯТО';
const statusDefecting = 'ДЕФЕКТОВКА';
const good = 'Удовлетворительно';
const bad = 'Неудовлетворительно';
const jobResults = [good, bad];
const scriptTakeInWork = 'ILCTAKEINWORK';
const scriptDutyComp = 'ILCDUTYCOMP';
const scriptItrComp = 'ILCITRCOMP'; // Отправить на согласование ЗДЭ
const scriptZdeConfirm = 'ILCZDECOMP';
const scriptZdeCancel = 'ILCZDECAN';
const scriptReportEquipmentFailure = 'ILCITRDA';
const rzProblemSolvedScript = 'ILCDF1';
const rzProblemUnSolvedScript = 'ILCDF2';
const gap5 = SizedBox(height: 5);
const gap10 = SizedBox(height: 10);
const gap20 = SizedBox(height: 20);
const gap30 = SizedBox(height: 30);
const gap40 = SizedBox(height: 40);
const span5 = SizedBox(width: 5);
const span10 = SizedBox(width: 10);
const span20 = SizedBox(width: 20);
const span30 = SizedBox(width: 30);
const span40 = SizedBox(width: 40);
```

## File: lib/core/dialogs.dart
```dart
import 'dart:io';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/audit/redux/audits_actions.dart';
import 'package:inspector_tps/audit/redux/audits_state.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/audit/rs_defect_comment.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/ppr/woactivity.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
void infoDialog(BuildContext context, {required String message}) {
 showDialog(
 context: context,
 builder: (context) => AlertDialog(
 content: Text(message),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.ok)),
 ],
 ),
 );
}
void displayPhotoDialog(BuildContext context, String path,
 {int? id, String? wonum, required CameraMode mode}) {
 final image = File(path);
 showDialog(
 context: context,
 builder: (context) => Dialog.fullscreen(
 backgroundColor: Colors.black,
 insetAnimationDuration: const Duration(milliseconds: 300),
 child: Column(
 children: [
 const Spacer(),
 Image.file(image),
 const Spacer(),
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceAround,
 children: [
 TextButton(
 onPressed: () async {
 await deletePhoto(context,
 id: id, wonum: wonum, path: path, mode: mode);
 if (context.mounted) {
 context.pop();
 }
 },
 child: Text(Txt.deletePhoto)),
 TextButton(onPressed: context.pop, child: Text(Txt.ok)),
 ],
 ),
 const SizedBox(height: 50),
 ],
 ),
 ),
 );
}
void deleteAuditDialog(BuildContext context, WorkTaskMobile audit) {
 showDialog(
 context: context,
 builder: (context) => AlertDialog(
 title: Text(Txt.deleteAuditDialogTitle),
 content: Text(
 Txt.deleteAuditDialogContent('${audit.wonum} ${audit.description}')),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () {
 context.store.dispatch(deleteAuditAction(audit.wonum ?? ''));
 context.pop();
 context.go(AppRoute.audit.route);
 },
 child: Text(Txt.delete)),
 ],
 ),
 );
}
void sentChecklistsResultDialog(
 BuildContext context,
 String wonum,
) {
 showDialog(
 context: context,
 barrierDismissible: false,
 builder: (context) => StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state.auditsState),
 builder: (context, vm) {
 return AlertDialog(
 title: Text(Txt.sendingAuditToMaximoDialogTitle),
 content: Text(Txt.sentAuditToMaximoResultDialogContent(
 vm.count, wonum, vm.total)),
 actions: [
 if (vm.showCloseButton)
 TextButton(
 onPressed: () {
 context.store.dispatch(SendingAuditCountAction(null));
 context.store.dispatch(TotalToUploadingAction(0));
 context.pop();
 },
 child: Text(Txt.ok)),
 ],
 );
 }),
 );
}
class _VM extends Equatable {
 final AuditsState state;
 const _VM(this.state);
 int get count => state.sendingAuditCount;
 int get total => state.totalToUploading;
 bool get showCloseButton => !state.showSendingDialog;
 @override
 List<Object?> get props => [count, showCloseButton];
}
void addRsDefectComment(BuildContext context, ChecklistWo wo) {
 final TextEditingController controller = TextEditingController();
 showDialog(
 context: context,
 builder: (context) => AlertDialog(
 title: Text(Txt.addComment),
 content: SingleChildScrollView(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text('${wo.number}'),
 const SizedBox(height: 20),
 TextField(
 controller: controller,
 maxLines: null,
 keyboardType: TextInputType.multiline,
 maxLength: 999,
 ),
 ],
 ),
 ),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () async {
 final comment = controller.text.trim();
 final wonum = wo.woNum;
 final id = wo.checklistWoId;
 final checklistOperationId = wo.checklistOperationId;
 if (comment.isNotEmpty &&
 wonum != null &&
 id != null &&
 checklistOperationId != null) {
 context.store.dispatch(
 addCommentAction(
 wonum: wonum,
 checklistwoid: id,
 checklistOperationId: checklistOperationId,
 parentId: wo.parentId ?? -1,
 comment: comment,
 siteId: wo.siteId ?? '',
 ),
 );
 }
 context.pop();
 },
 child: Text(Txt.save)),
 ],
 ),
 );
}
void deleteRsDefectCommentDialog(
 BuildContext context, RsDefectComment comment, ChecklistWo wo) {
 showDialog(
 context: context,
 builder: (context) => AlertDialog(
 title: Text(Txt.deleteRsDefectCommentDialogTitle),
 content: Text(comment.comment ?? ''),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () {
 context.store.dispatch(deleteRsDefectCommentAction(
 comment: comment,
 parentId: wo.parentId ?? -1,
 checklistwoid: wo.checklistWoId ?? -1));
 context.pop();
 },
 child: Text(Txt.delete)),
 ],
 ),
 );
}
void addPprCommentDialogWithAction(
 BuildContext context,
 WorkTaskMobile ppr, {
 bool reportEquipmentFailure = false,
 bool reject = false,
 required bool isPhotoComment,
}) {
 final TextEditingController controller = TextEditingController();
 final title = isPhotoComment
 ? Txt.addCommentToAttachedPhoto
 : '${Txt.addComment} ${ppr.wonum}';
 showDialog(
 barrierDismissible: false,
 context: context,
 builder: (context) => AlertDialog(
 title: Text(title, style: _accCommentTitleStyle),
 content: SingleChildScrollView(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text(ppr.description ?? ''),
 const SizedBox(height: 20),
 TextField(
 controller: controller,
 maxLines: null,
 keyboardType: TextInputType.multiline,
 maxLength: 999,
 ),
 ],
 ),
 ),
 actions: [
 if (!isPhotoComment)
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () async {
 final comment = controller.text.trim();
 if (comment.isEmpty) {
 ScaffoldMessenger.of(context)
 .showSnackBar(SnackBar(content: Text(Txt.shouldAddComment)));
 return;
 }
 if (reportEquipmentFailure) {
 context.store.dispatch(reportEquipmentFailureWithCommentAction(
 ppr.wonum!, ppr.href, comment, ppr.doclinks?.href));
 } else if (reject) {
 context.store.dispatch(cancelPprAction(
 ppr.wonum!, ppr.href, comment, ppr.doclinks?.href));
 } else {
 context.store.dispatch(addCommentToPprAction(
 wonum: ppr.wonum!, comment: controller.text.trim()));
 if (appStore.state.isConnected) {
 appStore.dispatch(
 sendCommentToMaximoAction(
 ppr.wonum ?? '', ppr.href, ppr.doclinks?.href,
 isPpr: true),
 );
 }
 }
 context.pop();
 },
 child: Text(
 _getActionButtonText(
 report: reportEquipmentFailure,
 reject: reject,
 isPhotoComment: isPhotoComment,
 ),
 ),
 ),
 ],
 ),
 );
}
String _getActionButtonText(
 {required bool report,
 required bool reject,
 required bool isPhotoComment}) {
 if (report) return Txt.report;
 if (reject) return Txt.rejectPpr;
 bool isConnected = appStore.state.isConnected;
 if (isPhotoComment && isConnected) return Txt.sendPhotoWithComment;
 return Txt.save;
}
const _accCommentTitleStyle = TextStyle(fontSize: 15, color: accent);
void addJobCommentDialog(BuildContext context, Woactivity job) {
 final TextEditingController controller = TextEditingController()
 ..text = job.pprcomment ?? '';
 showDialog(
 barrierDismissible: false,
 context: context,
 builder: (context) => AlertDialog(
 title: Text(
 Txt.addComment,
 style: _accCommentTitleStyle,
 ),
 content: SingleChildScrollView(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text('${job.description}'),
 const SizedBox(height: 20),
 TextField(
 controller: controller,
 maxLines: null,
 keyboardType: TextInputType.multiline,
 maxLength: 250,
 ),
 ],
 ),
 ),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () {
 context.store.dispatch(addJobtaskCommentAction(
 wonum: job.wonum!,
 wosequence: job.wosequence ?? -1,
 comment: controller.text.trim(),
 ));
 context.pop();
 },
 child: Text(Txt.save)),
 ],
 ),
 );
}
void addRzCommentDialog(BuildContext context, WorkTaskMobile rz) {
 final TextEditingController controller = TextEditingController();
 showDialog(
 barrierDismissible: false,
 context: context,
 builder: (context) => AlertDialog(
 title:
 Text('${Txt.addComment} ${rz.wonum}', style: _accCommentTitleStyle),
 content: SingleChildScrollView(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text(rz.description ?? ''),
 const SizedBox(height: 20),
 TextField(
 controller: controller,
 maxLines: null,
 keyboardType: TextInputType.multiline,
 maxLength: 999,
 ),
 ],
 ),
 ),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () async {
 final comment = controller.text.trim();
 if (comment.isEmpty) {
 ScaffoldMessenger.of(context).showSnackBar(
 SnackBar(content: Text(Txt.shouldAddComment)));
 return;
 }
 context.store.dispatch(addCommentToRzAction(
 wonum: rz.wonum!, comment: controller.text.trim()));
 context.pop();
 },
 child: Text(Txt.save)),
 ],
 ),
 );
}
void downloadAssetsDialog(
 BuildContext context,
) {
 showDialog(
 context: context,
 builder: (context) => AlertDialog(
 title: Text(Txt.assets),
 content: Text(Txt.downloadAssets),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () {
 context.pop();
 context.store.dispatch(downloadAssetsCatalogAction());
 },
 child: Text(Txt.download)),
 ],
 ));
}
void deleteClaimDialog(BuildContext context, Sr sr) {
 showDialog(
 context: context,
 builder: (context) => AlertDialog(
 title: Text(Txt.deleteClaimDialogTitle),
 content: Text(Txt.deleteClaimDialogContent),
 actions: [
 TextButton(
 onPressed: () {
 context.pop();
 },
 child: Text(Txt.cancel)),
 TextButton(
 onPressed: () {
 context.store.dispatch(deleteSrAction(sr));
 context.pop();
 },
 child: Text(Txt.delete)),
 ],
 ),
 );
}
```

## File: lib/core/redux/actions.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/error/app_error.dart';
@immutable
abstract class AppStateAction {}
class ShowLoader implements AppStateAction {}
class HideLoader implements AppStateAction {}
class IsDevAction implements AppStateAction {
 final bool isDev;
 IsDevAction(this.isDev);
}
class AppErrorAction implements AppStateAction {
 final AppError error;
 AppErrorAction(this.error);
}
class ClearErrorAction implements AppStateAction {}
class ClearStateAction implements AppStateAction {}
class TabIndexAction extends AppStateAction {
 final int index;
 TabIndexAction(this.index);
}
class IsConnectedAction extends AppStateAction {
 final bool connected;
 IsConnectedAction(this.connected);
}
```

## File: lib/core/redux/app_state.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/audit/redux/audits_state.dart';
import 'package:inspector_tps/auth/redux/user_state.dart';
import 'package:inspector_tps/claims/redux/claims_state.dart';
import 'package:inspector_tps/error/app_error.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
@immutable
class AppState {
 final UserState userState;
 final AuditsState auditsState;
 final PprState pprState;
 final ClaimsState claimsState;
 final bool showLoader;
 final AppError? error;
 final int tabIndex;
 final bool isDev;
 final bool isConnected;
 const AppState._({
 required this.userState,
 required this.auditsState,
 required this.pprState,
 required this.claimsState,
 this.error,
 this.showLoader = false,
 this.isDev = false,
 this.tabIndex = 0,
 this.isConnected = false,
 });
 factory AppState.initial() => AppState._(
 userState: UserState.initial(),
 auditsState: AuditsState.initial(),
 pprState: PprState.initial(),
 claimsState: ClaimsState.initial(),
 error: null,
 showLoader: false,
 isDev: false,
 tabIndex: 0,
 isConnected: false,
 );
 AppState copyWith({
 UserState? userState,
 AuditsState? auditsState,
 PprState? pprState,
 ClaimsState? claimsState,
 bool? showLoader,
 bool? isDev,
 AppError? error,
 int? tabIndex,
 bool clearError = false,
 bool? isConnected,
 }) {
 return AppState._(
 userState: userState ?? this.userState,
 auditsState: auditsState ?? this.auditsState,
 pprState: pprState ?? this.pprState,
 claimsState: claimsState ?? this.claimsState,
 showLoader: showLoader ?? this.showLoader,
 isDev: isDev ?? this.isDev,
 error: clearError ? null : (error ?? this.error),
 tabIndex: tabIndex ?? this.tabIndex,
 isConnected: isConnected ?? this.isConnected,
 );
 }
 bool get hasError => error != null;
}
```

## File: lib/core/redux/reducer.dart
```dart
import 'package:inspector_tps/audit/redux/audits_reducer.dart';
import 'package:inspector_tps/auth/redux/reducer.dart';
import 'package:inspector_tps/claims/redux/claims_reducer.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/ppr/redux/ppr_reducer.dart';
AppState appStateReducer(AppState state, dynamic action) {
 if (action is ShowLoader) {
 return state.copyWith(showLoader: true);
 } else if (action is IsDevAction) {
 return state.copyWith(isDev: action.isDev);
 } else if (action is HideLoader) {
 return state.copyWith(showLoader: false);
 } else if (action is AppErrorAction) {
 return state.copyWith(error: action.error);
 } else if (action is ClearErrorAction) {
 return state.copyWith(clearError: true);
 } else if (action is TabIndexAction) {
 return state.copyWith(tabIndex: action.index);
 } else if (action is IsConnectedAction) {
 return state.copyWith(isConnected: action.connected);
 } else if (action is ClearStateAction) {
 return AppState.initial();
 }
 return state.copyWith(
 userState: userReducer(state.userState, action),
 auditsState: auditsReducer(state.auditsState, action),
 pprState: pprReducer(state.pprState, action),
 claimsState: claimsReducer(state.claimsState, action),
 );
}
```

## File: lib/core/router.dart
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/audit/view/audits_view.dart';
import 'package:inspector_tps/audit/view/checklist/checklist_view.dart';
import 'package:inspector_tps/auth/presentation/login_screen.dart';
import 'package:inspector_tps/auth/presentation/user_profile_view.dart';
import 'package:inspector_tps/claims/claims_view.dart';
import 'package:inspector_tps/claims/pick_asset_screen.dart';
import 'package:inspector_tps/claims/rz_detailed_view.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/photo_params.dart';
import 'package:inspector_tps/error/error_screen.dart';
import 'package:inspector_tps/home/home_screen.dart';
import 'package:inspector_tps/ppr/view/detailed/ppr_detailed_view.dart';
import 'package:inspector_tps/ppr/view/ppr_view.dart';
final _shellAudit = GlobalKey<NavigatorState>(debugLabel: 'shellAudit');
final _shellClaims = GlobalKey<NavigatorState>(debugLabel: 'shellClaims');
final _shellTo = GlobalKey<NavigatorState>(debugLabel: 'shellPpr');
final _shellProfile = GlobalKey<NavigatorState>(debugLabel: 'shellProfile');
enum AppRoute {
 login,
 audit,
 auditDetailed,
 claims,
 rzDetailed,
 pickAssetRoute,
 ppr,
 pprDetailed,
 profile,
 camera,
 error;
 String get route => '/$name';
 static AppRoute getRouteByIndex(int index) => switch (index) {
 0 => audit,
 1 => claims,
 2 => ppr,
 4 => profile,
 _ => profile,
 };
}
Page getPage({
 required Widget child,
 required GoRouterState state,
}) {
 return MaterialPage(
 key: state.pageKey,
 child: child,
 );
}
class AppNavigator {
 static final AppNavigator _instance = AppNavigator._internal();
 late GoRouter router;
 AppNavigator._internal();
 factory AppNavigator() {
 _instance.router = GoRouter(
 debugLogDiagnostics: true,
 initialLocation: AppRoute.audit.route,
 routes: [
 StatefulShellRoute.indexedStack(
 pageBuilder: (context, state, navigationShell) {
 return getPage(
 child: BottomNavigationPage(
 navigationShell: navigationShell,
 ),
 state: state);
 },
 branches: [
 StatefulShellBranch(
 navigatorKey: _shellAudit,
 initialLocation: AppRoute.audit.route,
 routes: [
 GoRoute(
 path: AppRoute.audit.route,
 pageBuilder: (context, state) => getPage(
 child: AuditsView(key: UniqueKey()), state: state),
 ),
 GoRoute(
 path: AppRoute.auditDetailed.route,
 pageBuilder: (context, state) => getPage(
 child: ChecklistView(key: UniqueKey()), state: state),
 ),
 ],
 ),
 StatefulShellBranch(
 navigatorKey: _shellClaims,
 routes: [
 GoRoute(
 path: AppRoute.claims.route,
 pageBuilder: (context, state) => getPage(
 child: ClaimsView(key: UniqueKey()), state: state),
 ),
 GoRoute(
 path: AppRoute.rzDetailed.route,
 pageBuilder: (context, state) => getPage(
 child: RzDetailedView(key: UniqueKey()), state: state),
 ),
 GoRoute(
 path: AppRoute.pickAssetRoute.route,
 pageBuilder: (context, state) => getPage(
 child: PickAssetScreen(key: UniqueKey()), state: state),
 ),
 ],
 ),
 StatefulShellBranch(
 navigatorKey: _shellTo,
 routes: [
 GoRoute(
 path: AppRoute.ppr.route,
 pageBuilder: (context, state) =>
 getPage(child: PprView(key: UniqueKey()), state: state),
 ),
 GoRoute(
 path: AppRoute.pprDetailed.route,
 pageBuilder: (context, state) => getPage(
 child: PprDetailedView(key: UniqueKey()), state: state),
 ),
 ],
 ),
 StatefulShellBranch(
 navigatorKey: _shellProfile,
 routes: [
 GoRoute(
 path: AppRoute.profile.route,
 pageBuilder: (context, state) => getPage(
 child: UserProfileView(
 key: UniqueKey(),
 ),
 state: state),
 ),
 ],
 ),
 ],
 ),
 GoRoute(
 path: AppRoute.login.route,
 builder: (context, state) => const LoginScreen()),
 GoRoute(
 path: AppRoute.error.route,
 builder: (context, state) => const ErrorScreen()),
 GoRoute(
 path: AppRoute.camera.route,
 builder: (context, state) {
 final params = state.extra as PhotoParams;
 return CameraScreen(
 wonum: params.wonum,
 checklistWoId: params.checklistwoid,
 mode: params.mode,
 );
 },
 ),
 ],
 redirect: (context, routerState) {
 final state = context.store.state;
 if (state.hasError) {
 return AppRoute.error.route;
 }
 if (!state.userState.isAuthorized) {
 return AppRoute.login.route;
 }
 return null;
 },
 );
 return _instance;
 }
}
```

## File: lib/core/services/connectivity_service.dart
```dart
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/cupertino.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/sl.dart';
class ConnectivityService {
 final _connectivity = Connectivity();
 ConnectivityService() {
 _checkConnectivity();
 }
 void _checkConnectivity() async {
 updateConnectionStatus(await _connectivity.checkConnectivity());
 Connectivity().onConnectivityChanged.listen(updateConnectionStatus);
 }
 void updateConnectionStatus(List<ConnectivityResult> result) {
 final isConnected = result.any((element) =>
 [ConnectivityResult.mobile, ConnectivityResult.wifi].contains(element));
 debugPrint('is connected: $isConnected');
 appStore.dispatch(IsConnectedAction(isConnected));
 }
 void initConnectivityStatus() async {
 final connected = await _connectivity.checkConnectivity();
 final isConnected = connected.any((element) =>
 [ConnectivityResult.mobile, ConnectivityResult.wifi].contains(element));
 debugPrint('is connected: $isConnected');
 appStore.dispatch(IsConnectedAction(isConnected));
 }
}
```

## File: lib/core/sl.dart
```dart
import 'package:camera/camera.dart';
import 'package:get_it/get_it.dart';
import 'package:inspector_tps/data/maximo_repository.dart';
import 'package:inspector_tps/auth/user_controller.dart';
import 'package:inspector_tps/auth/user_repository.dart';
import 'package:inspector_tps/core/api/maximo_session.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/redux/reducer.dart';
import 'package:inspector_tps/core/services/connectivity_service.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sqflite/sqflite.dart';
final sl = GetIt.instance;
Future<void> initSl() async {
 sl.registerSingleton<SharedPreferences>(
 await SharedPreferences.getInstance());
 sl.registerSingleton<MaximoSession>(MaximoSession());
 sl.registerSingleton<UserRepository>(UserRepository(sl()));
 sl.registerSingleton<UserController>(UserController(sl()));
 sl.registerSingleton<MaximoRepository>(MaximoRepository(sl()));
 sl.registerSingleton<Database>(await openAuditDatabase());
 final store = Store<AppState>(
 appStateReducer,
 initialState: AppState.initial(),
 middleware: [
 thunkMiddleware,
 ],
 );
 sl.registerSingleton(store);
 final cameras = await availableCameras();
 if (cameras.isNotEmpty) {
 _camera = cameras.first;
 }
 sl.registerSingleton(ConnectivityService());
}
late final CameraDescription _camera;
SharedPreferences get prefs => sl<SharedPreferences>();
CameraDescription get appCamera => _camera;
Store<AppState> get appStore => sl<Store<AppState>>();
UserController get userController => sl<UserController>();
Database get db => sl<Database>();
MaximoRepository get maximoRepository => sl<MaximoRepository>();
ConnectivityService get connectivityService => sl<ConnectivityService>();
```

## File: lib/core/txt.dart
```dart
import 'package:inspector_tps/core/api/endpoints.dart';
abstract class Txt {
 static const appName = 'TPS';
 static const tps = 'ТПС';
 static const estate = 'Недвижимость';
 static const enter = 'Войти';
 static const logout = 'Выйти из аккаунта';
 static const login = 'Логин';
 static const pwd = 'Пароль';
 static const groups = 'Группы пользователя:';
 static const tabAudit = 'Аудиты';
 static String audits = 'Список аудитов';
 static const tabProfile = 'Профиль';
 static const tabClaims = 'Заявки';
 static const tabTo = 'ППР';
 static const somethingWentWrong = 'Что-то пошло не так, попробуйте еще раз';
 static const unauthorizedMessage = 'Не верный логин или пароль';
 static const close = 'Закрыть';
 static const errorTitle = 'Ошибка';
 static const offline = 'Устройство не подключено к интернету,\n'
 'повторите оперцию при наличие соединения';
 static var locallySaved = 'Статус не передан в Максимо';
 static String pprs = 'Список ППР';
 static String noPpr = 'Нет загруженных ППР';
 static String noPprForShift = 'ППР на текущую смену отсутствуют';
 static String downloadPprMonth = 'Загрузить список ППР';
 static String downloadPprWeek = 'Загрузить ППР за неделю';
 static String downloadPprWorkShift = 'Загрузить ППР за смену (сутки и новые)';
 static String updatePprList = 'Добавить утвержденные ППР из Максимо';
 static String clearPprList = 'Удалить все загруженные ППР';
 static String clearCompletedPpr = 'Удалить завершенные ППР';
 static String currentShift = 'Текущая смена';
 static String outdated = 'Просроченные';
 static String allPpr = 'Всe загруженные ППР';
 static String completedPpr = 'Завершенные ППР';
 static String plannedJob = 'Плановая работа';
 static String statusCond = 'Состояние';
 static String fromWho = 'От кого';
 static String priority = 'Приоритет';
 static String systemCategory = 'Квтегория системы';
 static String plannedStart = 'Плановое начало';
 static String plannedFinish = 'Плановое окончание';
 static String assetDescription = 'Объект эксплуатации';
 static String assetLocation = 'Местоположение';
 static String takeInWork = 'Взять в работу';
 static String sendForApprovalZde = "Отправить на согласование ЗДЭ";
 static String reportEquipmentFailure =
 'Сообщить о неработоспособности оборудования';
 static String registerToDescription =
 '\u002A Для регистрации внепланового ТО требуется выполнить действие в веб-версии системы';
 static var completePprDescription =
 'Для завершения работы требуется указать статус всех операций.\n\n'
 'Для операций со статусом "Неудовлетворительно" требуется заполнить комментарий.';
 static String sendReadyPpr = 'Передать готовые ППР в Максимо';
 static String addCommentToAttachedPhoto =
 'Добавьте комментарий для приложенных снимков';
 static String sendPhotoWithComment = "Отправить";
 static String sendChanges = "Отправить изменения";
 static String rzList = 'Все РЗ';
 static String rzs = 'Рабочие задания';
 static String rz = 'РЗ';
 static String claims = 'Заявки';
 static String noRz = 'Нет загруженных РЗ';
 static String noRzForShift = 'РЗ на текущую смену отсутствуют';
 static String downloadRz = 'Загрузить список РЗ';
 static String newClaim = 'Новая заявка';
 static String pickSite = 'Площадка:';
 static String create = 'Создать';
 static String createNewClaim = 'Создать новую заявку';
 static String saveNewClaim = 'Сохранить';
 static String enterLocation = 'Заполните местопложение';
 static String enterDescription = 'Заполните описание';
 static String locationDescription = 'Описание местоположения';
 static String claimText = 'Текст заявки';
 static String sentClaims = 'Отправленные заявки';
 static String savedClaims = 'Сохраненные заявки';
 static String sendSavedClaims = 'Отправить сохраненные заявки';
 static String sendSavedRz = 'Передать готовые РЗ в Максимо';
 static String addRzComment = 'Добавить комментарий';
 static String claimFrom = 'Заявка от: ';
 static String renewAssets = 'Обновить справочник объектов эксплуатации';
 static String downloadSites = 'Загрузить площадки';
 static String downloadAssets = 'Загрузить справочник объектов эксплуатации';
 static String assets = 'Справочник объектов эксплуатации';
 static String asset = 'Объект эксплуатации';
 static String claim = 'Заявка';
 static String pickAsset = 'Выбрать объект эксплуатации';
 static String searchAsset = 'Поиск объекта эксплуатации';
 static String assetsCount = 'Всего объектов:';
 static String clearRzList = 'Удалить все загруженные РЗ';
 static String clearPreApprovedRz = 'Удалить обработанные РЗ';
 static String shouldAddCommentButton = 'Необходимо добавить комментарий';
 static String deleteClaimDialogTitle = 'Удаление заявки';
 static String deleteClaimDialogContent = 'Заявка будет удалена с устройства!';
 static String factorValue = 'Значение фактора';
 static String noAudits = 'Нет загруженных аудитов';
 static String downloadAudits = 'Загрузить аудиты из Maximo';
 static String downloadChecklist = 'Загрузить чек-лист аудита';
 static String downloadDescription =
 'Чек-лист данного аудита не был загружен на устройство.';
 static String downloadDescription2 =
 '(Для загрузки необходимо устойчивое подключение к интернету.)';
 static String deleteAudit = 'Удалить аудит с устройства';
 static String sendAuditToMaximo =
 'Передать результат прохождения аудита в Максимо';
 static String updateAuditsList = 'Добавить сформированные аудиты из Максимо';
 static String deleteAuditDialogTitle = 'Удаление аудита';
 static String deleteRsDefectCommentDialogTitle = 'Удаление комментария';
 static String changeContourDialogTitle = 'Сменить контур';
 static String sendingAuditToMaximoDialogTitle = 'Отправка аудита в Максимо';
 static String teReportData = 'Данные отчета ТЭ';
 static String changeAddress = 'Сменить адрес';
 static String internetNeededForDataSending =
 'Требуется наличие надежного интернет соединения для отправки данных на сервер';
 static String internetNeededForDataLoading =
 'Требуется наличие надежного интернет соединения для загрузки данных';
 static String sentAuditToMaximoResultDialogContent(
 int count, String wonum, int total) =>
 'Аудит: $wonum\n'
 'Всего к отправке: $total\n'
 'Обновлено пунктов чек-листа: $count';
 static String checklistBack = 'Назад';
 static String status = 'Статус';
 static String comment = 'Комментарий';
 static String downloadedComments = 'Загруженные комментарии';
 static String myComments = 'Мои комментарии';
 static String changeComment = 'Изменить комментарий';
 static String addComment = 'Добавить комментарий';
 static String shouldAddComment = 'Добавьте комментарий';
 static String editCommentDialogTitle = 'Редактирование комментария';
 static String save = 'Сохранить';
 static String ok = 'Ок';
 static String deletePhoto = 'Удалить фото';
 static String deleteAuditDialogContent(String name) =>
 'Аудит $name\nбудет удален с устройства.\n\n'
 'Данные не переданные в Maximo будут утеряны.\n\n'
 'Вы уверены, что аудит пройден или больше не нужен на устройстве?';
 static String cancel = 'Отмена';
 static String closeMenu = 'Закрыть меню';
 static String delete = 'Удалить';
 static String tech = 'Техническая эксплуатация';
 static String setProd = 'Установить рабочий контур';
 static String setDev = 'Установить контур разработки';
 static String addPprComment = 'Добавить комментарий к ППР';
 static String downloaded = 'Загруженные комментарии';
 static String fresh = 'Новые комментарии';
 static var allOperationsCompleted = 'Все операции выполнены';
 static var finish = 'Завершить';
 static String pprCompleted = 'ППР завершен';
 static String doNotCloseSendingPpr = 'Не закрывайте вкладку и приложение!\n'
 'Идёт обмен данными...';
 static var estDur = 'минут на выполнение:';
 static String confirm = 'Подтвердить выполнение';
 static String reject = 'Отклонить';
 static String rejectPpr = 'Отклонить ППР';
 static String report = "Сообщить";
 static var version = 'Версия:';
 static String takeAPicture = 'Сделайте фото';
 static String finishUntil = 'Выполнить до: ';
 static String from = 'От:';
 static String download = 'Загрузить';
 static String solved = 'Устранено';
 static String unSolved = 'Не устранено';
}
String changeContourDialogDescription(bool isDev) {
 final url = getHost;
 return isDev
 ? 'Контур разработки\n$url'
 : 'Рабочий контур\n(Production)\n$url';
}
```

## File: lib/core/utils/core_utils.dart
```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/audit/redux/audit_thunks.dart';
import 'package:inspector_tps/auth/redux/user_state.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/maximo_repository.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/photo_params.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:redux/redux.dart';
extension ContextUtils on BuildContext {
 Store<AppState> get store => StoreProvider.of<AppState>(this);
 AppState get appState => store.state;
 UserState get userState => store.state.userState;
}
List<ChecklistWo> filterUnchecked(List<ChecklistWo> input) {
 if (input.isEmpty) return input;
 final bool areLeafs = input.last.checklist.isEmpty;
 if (areLeafs) return input.where((e) => !(e.rsMasterpoint ?? false)).toList();
 return input.where((e) => !isChecked(e)).toList();
}
bool isChecked(ChecklistWo chl) {
 return filterUnchecked(chl.checklist).isEmpty;
}
int initialTab(UserModel? user) {
 if ((user?.isDutyEng ?? false) || (user?.isItr ?? false)) {
 return 2;
 }
 return 0;
}
String getInitialHomeRoute(UserModel? user) {
 final index = initialTab(user);
 switch (index) {
 case 0:
 return AppRoute.audit.route;
 case 1:
 return AppRoute.claims.route;
 case 2:
 return AppRoute.ppr.route;
 default:
 return AppRoute.profile.route;
 }
}
void attachPhoto(
 BuildContext context, {
 required String wonum,
 required CameraMode mode,
 required int? checklistwoid,
}) {
 context.push(AppRoute.camera.route,
 extra:
 PhotoParams(wonum: wonum, mode: mode, checklistwoid: checklistwoid));
}
Future<void> deletePhoto(BuildContext context,
 {int? id,
 String? wonum,
 required String path,
 required CameraMode mode}) async {
 if (id != null) {
 await deleteImagePath(path: path);
 } else if (wonum != null) {
 await deleteWtmImagePath(path: path);
 }
 final image = File(path);
 await image.delete();
 if (!context.mounted) return;
 switch (mode) {
 case CameraMode.checklist:
 context.store.dispatch(findAndUpdateWoInLevels(checklistwoid: id ?? -1));
 break;
 case CameraMode.ppr:
 context.store.dispatch(readSelectedPprFromDbAction(wonum ?? ''));
 break;
 case CameraMode.rz:
 context.store.dispatch(readSelectedRzFromDbAction(wonum ?? ''));
 break;
 case CameraMode.claim:
 context.store.dispatch(readSrListFromDbAction());
 break;
 }
}
void downloadAssets(BuildContext context) {
 final isConnected = context.store.state.isConnected;
 if (!isConnected) {
 infoDialog(context, message: Txt.internetNeededForDataLoading);
 } else {
 context.store.dispatch(downloadAssetsCatalogAction());
 }
}
Future<bool> sendComments(String wonum, String? href) async {
 final freshComments = await readFreshCommentsByWonum(wonum);
 int count = 0;
 for (final comment in freshComments) {
 final success = await sl<MaximoRepository>()
 .addCommentToWorkTaskMobile(href ?? '', comment);
 if (success) count++;
 }
 return freshComments.length == count;
}
```

## File: lib/core/utils/time_utils.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
bool outdated(String input) {
 try {
 final date = DateTime.parse(input);
 return DateTime.now().compareTo(date) > 0;
 } catch (err) {
 return false;
 }
}
String dateFromIso(String input) {
 try {
 final date = DateTime.parse(input);
 return DateFormat('dd.MM.yy').format(date);
 } catch (err) {
 debugPrint(err.toString());
 return 'n/a';
 }
}
String dateTimeFromIso(String input) {
 try {
 final date = DateTime.parse(input);
 return DateFormat('dd.MM.yy HH:mm').format(date);
 } catch (err) {
 debugPrint(err.toString());
 return 'n/a';
 }
}
const monthMs = 30 * 24 * 60 * 60 * 1000;
const weekMs = 7 * 24 * 60 * 60 * 1000;
const dayMs = 24 * 60 * 60 * 1000;
String monthAgoIso({int monthsCount = 1}) {
 final now = DateTime.now().millisecondsSinceEpoch;
 return DateTime.fromMillisecondsSinceEpoch(now - monthMs * monthsCount)
 .toIso8601String()
 .split('T')[0];
}
String weekAgoIso() {
 final now = DateTime.now().millisecondsSinceEpoch;
 return DateTime.fromMillisecondsSinceEpoch(now - weekMs)
 .toIso8601String()
 .split('T')[0];
}
String dayAgoIso() {
 final now = DateTime.now().millisecondsSinceEpoch;
 return DateTime.fromMillisecondsSinceEpoch(now - dayMs)
 .toIso8601String()
 .split('T')[0];
}
String todayIso() {
 return DateTime.now().toIso8601String().split('T')[0];
}
String todayFullIso() {
 return DateTime.now().toIso8601String();
}
String tomorrowIso() {
 final now = DateTime.now().millisecondsSinceEpoch;
 return DateTime.fromMillisecondsSinceEpoch(now + dayMs)
 .toIso8601String()
 .split('T')[0];
}
String theDayAfterTomorrowIso() {
 final now = DateTime.now().millisecondsSinceEpoch;
 return DateTime.fromMillisecondsSinceEpoch(now + dayMs + dayMs)
 .toIso8601String()
 .split('T')[0];
}
String theTwoDayAfterTomorrowIso() {
 final now = DateTime.now().millisecondsSinceEpoch;
 return DateTime.fromMillisecondsSinceEpoch(now + dayMs + dayMs + dayMs)
 .toIso8601String()
 .split('T')[0];
}
```

## File: lib/core/widgets/card_divider.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/colors.dart';
class CardDivider extends StatelessWidget {
 const CardDivider({super.key});
 @override
 Widget build(BuildContext context) {
 return Container(
 height: 0.5,
 color: primary.withOpacity(0.75),
 );
 }
}
```

## File: lib/core/widgets/connection_indicator.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
class ConnectionIndicator extends StatelessWidget {
 const ConnectionIndicator({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state.isConnected),
 builder: (context, vm) {
 return Container(
 decoration: BoxDecoration(
 color: vm.isConnected ? Colors.green : Colors.red,
 shape: BoxShape.circle,
 ),
 height: 10,
 width: 10,
 );
 });
 }
}
class _VM extends Equatable {
 final bool isConnected;
 const _VM(this.isConnected);
 @override
 List<Object?> get props => [isConnected];
}
```

## File: lib/core/widgets/loader_with_description.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/txt.dart';
class LoaderWithDescription extends StatelessWidget {
 const LoaderWithDescription({
 super.key,
 });
 @override
 Widget build(BuildContext context) {
 return Center(
 child: Column(
 children: [
 const CircularProgressIndicator(),
 gap40,
 Text(Txt.doNotCloseSendingPpr,
 textAlign: TextAlign.center),
 ],
 ),
 );
 }
}
```

## File: lib/core/widgets/ppr_completed_widget.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/txt.dart';
class PprCompletedWidget extends StatelessWidget {
 const PprCompletedWidget({
 super.key,
 });
 @override
 Widget build(BuildContext context) {
 return Center(child: Text(Txt.pprCompleted));
 }
}
```

## File: lib/core/widgets/round_count_widget.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/colors.dart';
class RoundCountWidget extends StatelessWidget {
 const RoundCountWidget({super.key, required this.count});
 final int count;
 @override
 Widget build(BuildContext context) {
 return Container(
 height: 28,
 width: 28,
 decoration: const BoxDecoration(
 shape: BoxShape.circle,
 color: Colors.white,
 ),
 child: Center(
 child: Text(count.toString(),
 style: const TextStyle(
 color: primary, fontSize: 11, fontWeight: FontWeight.bold)),
 ),
 );
 }
}
```

## File: lib/core/widgets/unsaved_icon_button.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/txt.dart';
class UnsavedIconButton extends StatelessWidget {
 const UnsavedIconButton({
 super.key,
 });
 @override
 Widget build(BuildContext context) {
 return InkWell(
 onTap: () {
 infoDialog(context, message: Txt.locallySaved);
 },
 child: const Icon(
 size: 20,
 Icons.save,
 color: accent,
 ));
 }
}
```

## File: lib/core/widgets/unsupported_for_groups_widget.dart
```dart
import 'package:flutter/material.dart';
class UnsupportedForGroupsWidget extends StatelessWidget {
 const UnsupportedForGroupsWidget({super.key});
 @override
 Widget build(BuildContext context) {
 return const Scaffold(
 body: Center(
 child: Text('Недоступно для ваших групп доступа'),
 ));
 }
}
```

## File: lib/data/local_storages/local_db.dart
```dart
import 'package:flutter/cupertino.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/audit/rs_defect_comment.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/ppr/woactivity.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/data/models/worklog/worklog.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
Future<Database> openAuditDatabase() async {
 final db = openDatabase(
 join(await getDatabasesPath(), 'audit_db.db'),
 version: 1,
 onCreate: (db, version) async {
 await db.execute(WorkTaskMobile.createAuditsTable);
 await db.execute(ChecklistWo.createTable);
 await db.execute(ChecklistWo.createChlwoImagesTable);
 await db.execute(RsDefectComment.createTable);
 await db.execute(WorkTaskMobile.createPprTable);
 await db.execute(Woactivity.createWoactivityTable);
 await db.execute(Worklog.createWorklogTable);
 await db.execute(WorkTaskMobile.createImagesTable);
 await db.execute(WorkTaskMobile.createRzTable);
 await db.execute(Asset.createAssetsTable);
 await db.execute(Sr.createSrTable);
 },
 );
 return db;
}
Future<void> resetAllDbData() async {
 await db.execute('DELETE FROM ${ChecklistWo.checkListWoTable}');
 await db.execute('DELETE FROM ${WorkTaskMobile.auditsTable}');
 await db.execute('DELETE FROM ${ChecklistWo.chlwoImagesTable}');
 await db.execute('DELETE FROM ${RsDefectComment.commentsTable}');
 await db.execute('DELETE FROM ${WorkTaskMobile.pprTable}');
 await db.execute('DELETE FROM ${Woactivity.woactivityTable}');
 await db.execute('DELETE FROM ${Worklog.worklogTable}');
 await db.execute('DELETE FROM ${WorkTaskMobile.imagesTable}');
 await db.execute('DELETE FROM ${WorkTaskMobile.rzTable}');
 await db.execute('DELETE FROM ${Asset.assetsTable}');
 await db.execute('DELETE FROM ${Sr.srTable}');
}
Future<void> insertAudits(List<WorkTaskMobile> audits) async {
 final batch = db.batch();
 for (var a in audits) {
 batch.insert(
 WorkTaskMobile.auditsTable,
 a.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await batch.commit();
}
Future<List<WorkTaskMobile>> readAllAudits() async {
 final List<Map<String, dynamic>> auditsMap =
 await db.query(WorkTaskMobile.auditsTable);
 return auditsMap.map((e) => WorkTaskMobile.fromMap(e)).toList();
}
Future<void> insertAuditCheckList(
 List<ChecklistWo> checkLists, String wonum) async {
 final batch = db.batch();
 for (var wo in checkLists) {
 if (wo.rsDefectcomment?.isNotEmpty ?? false) {
 final comments = wo.rsDefectcomment!;
 for (var c in comments) {
 c.woNum = wonum;
 }
 await insertRsDefectComments(comments);
 }
 if ((wo.number?.toLowerCase().startsWith('k') ?? false) &&
 wo.classid != null) continue;
 batch.insert(
 ChecklistWo.checkListWoTable,
 wo.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await batch.commit();
}
Future<void> insertRsDefectComments(List<RsDefectComment> comments) async {
 final batch = db.batch();
 for (var rsComment in comments) {
 batch.insert(
 RsDefectComment.commentsTable,
 rsComment.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await batch.commit();
}
Future<void> deleteRsDefectCommentDb(RsDefectComment comment) async {
 String query = 'DELETE FROM ${RsDefectComment.commentsTable} '
 'WHERE wonum = "${comment.woNum}" '
 'AND checklistwoid = "${comment.checklistWoId}" '
 'AND comment = "${comment.comment}"';
 await db.rawQuery(query);
}
Future<List<RsDefectComment>> readRsWorklogByChecklistoperationid(
 int checklistoperationid) async {
 final result =
 await db.rawQuery('SELECT * FROM ${RsDefectComment.commentsTable} '
 'WHERE checklistoperationid = "$checklistoperationid"');
 final comments = result.map((e) => RsDefectComment.fromMap(e)).toList();
 return comments;
}
Future<List<RsDefectComment>> readWoCommentsForUploading(
 int checklistoperationid) async {
 final comments =
 await readRsWorklogByChecklistoperationid(checklistoperationid);
 return comments
 .where((comment) => comment.rsDefectCommentId == null)
 .toList();
}
Future<List<ChecklistWo>> readAuditChecklists(String? wonum) async {
 final result = await db.rawQuery(
 'SELECT * FROM ${ChecklistWo.checkListWoTable} WHERE wonum = ? AND number IS NULL',
 [wonum]);
 final checklists = result.map((e) => ChecklistWo.fromMap(e)).toList();
 checklists.sort((a, b) => (a.number ?? (a.description ?? ''))
 .compareTo(b.number ?? (b.description ?? '')));
 for (var chl in checklists) {
 await addChildren(chl);
 }
 return checklists;
}
Future<void> addChildren(ChecklistWo parent) async {
 final result = await db.rawQuery(
 'SELECT * FROM ${ChecklistWo.checkListWoTable} WHERE wonum = ? AND parentId = ?',
 [parent.woNum, parent.checklistOperationId]);
 final checklists = result.map((e) => ChecklistWo.fromMap(e)).toList();
 checklists.sort((a, b) => (a.number ?? '').compareTo(b.number ?? ''));
 for (var chl in checklists) {
 addChildren(chl);
 }
 parent.checklist.addAll(checklists);
}
Future<List<ChecklistWo>> readLastLevel(
 String wonum, int parentId) async {
 final result = await db.rawQuery(
 'SELECT * FROM ${ChecklistWo.checkListWoTable} WHERE wonum = ? AND parentId = ?',
 [wonum, parentId]);
 final checklists = result.map((e) => ChecklistWo.fromMap(e)).toList();
 checklists.sort((a, b) => (a.number ?? '').compareTo(b.number ?? ''));
 for (var chl in checklists) {
 await _addChecklistWoComments(chl);
 }
 return checklists;
}
Future<List<ChecklistWo>> readChecklistsForUploading(String wonum) async {
 final result = await db.rawQuery(
 'SELECT * FROM ${ChecklistWo.checkListWoTable} WHERE wonum = "$wonum"'
 ' AND haschildren = 0 AND changed = 1');
 final leafs = result.map((e) => ChecklistWo.fromMap(e)).toList();
 for (var chl in leafs) {
 await _addChecklistWoComments(chl);
 }
 return leafs;
}
Future<ChecklistWo> readWo(int id) async {
 final result = await db.rawQuery(
 'SELECT * FROM ${ChecklistWo.checkListWoTable} WHERE checklistwoid = ?',
 [id]);
 final checklist = ChecklistWo.fromMap(result.first);
 await _addChecklistWoComments(checklist);
 final List<String> images =
 await readWoImagesPaths(checklistwoid: id, forSending: false);
 if (images.isNotEmpty) {
 checklist.addImages(images);
 }
 return checklist;
}
Future<void> _addChecklistWoComments(ChecklistWo checklist) async {
 if (!(checklist.hasChildren ?? false)) {
 final id = checklist.checklistOperationId ?? -1;
 final comments = await readRsWorklogByChecklistoperationid(id);
 if (comments.isNotEmpty) {
 for (var e in comments) {
 debugPrint('comment: ${checklist.number} ${e.comment}');
 }
 checklist.rsDefectcomment = comments;
 }
 }
}
Future<void> updateStatus(int checklistwoid, String status) async {
 await db.rawQuery(
 'UPDATE ${ChecklistWo.checkListWoTable} '
 'SET chliststatus = "$status", changed = "1" '
 'WHERE checklistwoid = "$checklistwoid"',
 );
}
Future<void> updateChanged(int checklistwoid) async {
 await db.rawQuery(
 'UPDATE ${ChecklistWo.checkListWoTable} '
 'SET changed = "1" '
 'WHERE checklistwoid = "$checklistwoid"',
 );
}
Future<void> updateFactor(int checklistwoid, double factor) async {
 await db.rawQuery(
 'UPDATE ${ChecklistWo.checkListWoTable} '
 'SET numberof = "$factor", changed = "1" '
 'WHERE checklistwoid = "$checklistwoid"',
 );
}
Future<void> updateChecked(int checklistwoid, int isChecked) async {
 await db.rawQuery(
 'UPDATE ${ChecklistWo.checkListWoTable} '
 'SET rs_masterpoint = "$isChecked", changed = "1" '
 'WHERE checklistwoid = "$checklistwoid"',
 );
}
Future<void> setChanged(int checklistwoid) async {
 await db.rawQuery(
 'UPDATE ${ChecklistWo.checkListWoTable} '
 'SET changed = "1" '
 'WHERE checklistwoid = "$checklistwoid"',
 );
}
Future<void> resetChanged(int checklistwoid) async {
 await db.rawQuery(
 'UPDATE ${ChecklistWo.checkListWoTable} '
 'SET changed = "0" '
 'WHERE checklistwoid = "$checklistwoid"',
 );
}
Future<void> setVisited(int checklistwoid) async {
 await db.rawQuery(
 'UPDATE ${ChecklistWo.checkListWoTable} '
 'SET visited = "1" '
 'WHERE checklistwoid = "$checklistwoid"',
 );
}
Future<void> insertChlwoImagePath({
 required int checklistwoid,
 required String wonum,
 required String path,
}) async {
 await db.rawQuery(
 'INSERT INTO ${ChecklistWo.chlwoImagesTable}(wonum, checklistwoid, path, sent) '
 'VALUES("$wonum", "$checklistwoid", "$path", "0")');
 await setChanged(checklistwoid);
}
Future<void> markImageAsSent(String path, String table) async {
 await db.rawQuery(
 'UPDATE $table '
 'SET sent = "1" '
 'WHERE path = "$path"',
 );
}
Future<void> deleteImagePath({
 required String path,
}) async {
 await db.rawQuery(
 'DELETE FROM ${ChecklistWo.chlwoImagesTable} WHERE path = "$path"');
}
Future<List<String>> readWoImagesPaths({
 required int checklistwoid,
 bool forSending = true,
}) async {
 final List<Map<String, Object?>> queryResult = await db.rawQuery(
 'SELECT * FROM ${ChecklistWo.chlwoImagesTable} '
 'WHERE checklistwoid = "$checklistwoid"${forSending ? 'AND sent = "0"' : ''}',
 );
 final result = <String>[];
 for (var m in queryResult) {
 result.add('${m['path']}');
 }
 return result;
}
Future<void> deleteAudit(String wonum) async {
 await db.rawQuery(
 'DELETE FROM ${ChecklistWo.chlwoImagesTable} WHERE wonum = $wonum',
 );
 await db.rawQuery(
 'DELETE FROM ${ChecklistWo.checkListWoTable} WHERE wonum = $wonum',
 );
 await db.rawQuery(
 'DELETE FROM ${WorkTaskMobile.auditsTable} WHERE wonum = $wonum',
 );
 await db.rawQuery(
 'DELETE FROM ${RsDefectComment.commentsTable} WHERE wonum = $wonum',
 );
}
Future<void> insertPpr(List<WorkTaskMobile> ppr,
 {bool fromMaximo = false}) async {
 final batch = db.batch();
 for (var p in ppr) {
 final jobBatch = db.batch();
 for (var job in p.woactivity ?? <Woactivity>[]) {
 job.wonum = p.wonum;
 jobBatch.insert(
 Woactivity.woactivityTable,
 job.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await jobBatch.commit();
 final worklogBatch = db.batch();
 for (var log in p.worklog ?? <Worklog>[]) {
 print(log.description);
 log.wonum = p.wonum;
 worklogBatch.insert(
 Worklog.worklogTable,
 log.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await worklogBatch.commit();
 p.pprTakenInMaximo = fromMaximo;
 batch.insert(
 WorkTaskMobile.pprTable,
 p.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await batch.commit();
}
Future<List<WorkTaskMobile>> readAllPpr() async {
 final List<Map<String, dynamic>> pprMap =
 await db.query(WorkTaskMobile.pprTable, orderBy: 'targcompdate, wonum');
 final pprList = await _addJobsAndComments(pprMap);
 for (var ppr in pprList) {
 _addImagesToWtm(ppr);
 }
 return pprList;
}
Future<List<WorkTaskMobile>> _addJobsAndComments(
 List<Map<String, dynamic>> pprMap) async {
 final pprs = pprMap.map((e) => WorkTaskMobile.fromMap(e)).toList();
 for (final ppr in pprs) {
 final List<Woactivity> jobs = await readJobTasksByWonum(ppr.wonum ?? '');
 ppr.woactivity = jobs;
 }
 return _addComments(pprs);
}
Future<List<WorkTaskMobile>> _addComments(List<WorkTaskMobile> pprs) async {
 for (final ppr in pprs) {
 final List<Worklog> comments = await readWorklogByWonum(ppr.wonum ?? '');
 ppr.worklog = comments;
 }
 return pprs;
}
Future<WorkTaskMobile> _addJobsAndCommentsToPpr(
 Map<String, dynamic> pprMap) async {
 final ppr = WorkTaskMobile.fromMap(pprMap);
 final List<Woactivity> jobs = await readJobTasksByWonum(ppr.wonum ?? '');
 ppr.woactivity = jobs;
 return _addCommentsToPpr(ppr);
}
Future<WorkTaskMobile> _addCommentsToPpr(WorkTaskMobile ppr) async {
 final List<Worklog> comments = await readWorklogByWonum(ppr.wonum ?? '');
 ppr.worklog = comments;
 return ppr;
}
Future<WorkTaskMobile> _addImagesToWtm(WorkTaskMobile wtm) async {
 final List<String> images =
 await readImagesPaths(wonum: wtm.wonum!, forSending: false);
 if (images.isNotEmpty) {
 wtm.addImages(images);
 }
 return wtm;
}
Future<WorkTaskMobile> readPprByWonum(String wonum) async {
 final query = ''
 'SELECT * FROM ${WorkTaskMobile.pprTable} '
 'WHERE wonum= $wonum'
 '';
 final List<Map<String, dynamic>> pprMap = await db.rawQuery(query);
 final ppr = await _addJobsAndCommentsToPpr(pprMap.first);
 await _addImagesToWtm(ppr);
 return ppr;
}
Future<List<WorkTaskMobile>> readTodayPpr() async {
 final query = ''
 'SELECT * FROM ${WorkTaskMobile.pprTable} '
 'WHERE targstartdate LIKE \'%${todayIso()}%\''
 'OR targcompdate LIKE \'%${todayIso()}%\''
 '';
 final List<Map<String, dynamic>> pprMap = await db.rawQuery(query);
 return _addJobsAndComments(pprMap);
}
Future<Iterable<String>> readCompletedPprWonums() async {
 const query = 'SELECT wonum FROM ${WorkTaskMobile.pprTable} '
 'WHERE status = "$statusCompleted" OR status = "$statusFullyCompleted"';
 final List<Map<String, dynamic>> pprWonums = await db.rawQuery(query);
 return pprWonums.map((e) => e['wonum']);
}
Future<Iterable<String>> readFreshCommentsByWonum(String wonum) async {
 final List<Map<String, dynamic>> result = await db.rawQuery(''
 'SELECT description FROM ${Worklog.worklogTable} '
 'WHERE wonum = "$wonum" AND fresh = "1"'
 '');
 return result.map((e) => e['description']);
}
Future<List<WorkTaskMobile>> readOutdatedPpr() async {
 final today = DateTime.now();
 final pprs = (await readAllPpr()).where((ppr) {
 final compDate = DateTime.parse(ppr.targcompdate ?? '');
 return compDate.compareTo(today) < 0;
 });
 return pprs.toList();
}
Future<List<WorkTaskMobile>> readCompletedPpr() async {
 final pprs = (await readAllPpr()).where((ppr) {
 return ppr.status == statusCompleted;
 });
 return pprs.toList();
}
Future<void> deletePpr(String wonum) async {
 await deleteJobTasksByWonum(wonum);
 await deleteCommentsByWonum(wonum);
 await db.rawQuery(
 'DELETE FROM ${WorkTaskMobile.pprTable} WHERE wonum = "$wonum"',
 );
}
Future<void> deleteAllPpr(List<String> wonums) async {
 await deleteAllJobTasks();
 await deleteAllWorklog(wonums);
 await deleteImagesByWonums(WorkTaskMobile.imagesTable, wonums);
 await db.rawQuery('DELETE FROM ${WorkTaskMobile.pprTable}');
}
Future<void> deleteImagesByWonums(String table, List<String> wonums) async {
 String join = wonums.join('","');
 String query = 'DELETE FROM $table WHERE wonum IN ("$join")';
 await db.rawQuery(query);
}
Future<void> deleteSentImages(String table) async {
 String query = 'DELETE FROM $table WHERE sent = "1"';
 await db.rawQuery(query);
}
Future<List<Woactivity>> readJobTasksByWonum(String wonum) async {
 final result = await db.rawQuery(
 'SELECT * FROM ${Woactivity.woactivityTable} WHERE wonum = "$wonum"');
 final tasks = result.map((e) => Woactivity.fromMap(e)).toList();
 return tasks;
}
Future<void> updateJobtaskResult({
 required String wonum,
 required int wosequence,
 required String result,
}) async {
 await db.rawQuery(
 'UPDATE ${Woactivity.woactivityTable} '
 'SET pprresult = "$result" '
 'WHERE wonum = "$wonum" AND wosequence="$wosequence"',
 );
}
Future<void> takePprInWorkLocally(String wonum) async {
 await db.rawQuery(
 'UPDATE ${WorkTaskMobile.pprTable} '
 'SET status = "$statusAssigned", pprTakenInMaximo = "0"'
 'WHERE wonum = "$wonum"',
 );
}
Future<void> pprTakenInMaximo(String wonum) async {
 await db.rawQuery(
 'UPDATE ${WorkTaskMobile.pprTable} '
 'SET pprTakenInMaximo = "1" '
 'WHERE wonum = "$wonum"',
 );
}
Future<void> completePprJobs({
 required String wonum,
}) async {
 await db.rawQuery(
 'UPDATE ${Woactivity.woactivityTable} '
 'SET pprresult = "$good" '
 'WHERE wonum = "$wonum"',
 );
}
Future<void> addJobtaskComment({
 required String wonum,
 required int wosequence,
 required String comment,
}) async {
 await db.rawQuery(
 'UPDATE ${Woactivity.woactivityTable} '
 'SET pprcomment= "$comment" '
 'WHERE wonum = "$wonum" AND wosequence="$wosequence"',
 );
}
Future<void> addCommentToWorklogTable(String wonum, String comment) async {
 await db.rawQuery(
 'INSERT INTO ${Worklog.worklogTable}(wonum, description, fresh) '
 'VALUES("$wonum", "$comment", "1")');
}
Future<void> deleteAllJobTasks() async {
 await db.rawQuery('DELETE FROM ${Woactivity.woactivityTable}');
}
Future<void> deleteJobTasksByWonum(String wonum) async {
 await db.rawQuery(
 'DELETE FROM ${Woactivity.woactivityTable} WHERE wonum = "$wonum"',
 );
}
Future<List<Worklog>> readWorklogByWonum(String wonum) async {
 final result = await db
 .rawQuery('SELECT * FROM ${Worklog.worklogTable} WHERE wonum = "$wonum"');
 final comments = result.map((e) => Worklog.fromMap(e)).toList();
 return comments;
}
Future<void> deleteAllWorklog(List<String> wonums) async {
 String join = wonums.join('","');
 await db
 .rawQuery('DELETE FROM ${Worklog.worklogTable} WHERE wonum IN ("$join")');
}
Future<void> deleteCommentsByWonum(String wonum) async {
 await db.rawQuery(
 'DELETE FROM ${Worklog.worklogTable} WHERE wonum = "$wonum"',
 );
}
Future<void> deleteComment(String wonum, String comment) async {
 await db
 .rawQuery('DELETE FROM ${Worklog.worklogTable} WHERE wonum = "$wonum" '
 'AND description = "$comment"');
}
Future<void> insertWtmImagePath({
 required String wonum,
 required String path,
}) async {
 await db
 .rawQuery('INSERT INTO ${WorkTaskMobile.imagesTable}(wonum, path, sent) '
 'VALUES("$wonum", "$path", "0")');
}
Future<void> deleteWtmImagePath({
 required String path,
}) async {
 await db.rawQuery(
 'DELETE FROM ${WorkTaskMobile.imagesTable} WHERE path = "$path"');
}
Future<List<String>> readImagesPaths({
 required String wonum,
 bool forSending = true,
}) async {
 final List<Map<String, Object?>> queryResult = await db.rawQuery(
 'SELECT * FROM ${WorkTaskMobile.imagesTable} '
 'WHERE wonum = "$wonum"${forSending ? 'AND sent = "0"' : ''}',
 );
 final result = <String>[];
 for (var m in queryResult) {
 result.add('${m['path']}');
 }
 return result;
}
Future<void> insertRz(List<WorkTaskMobile> rzList) async {
 final batch = db.batch();
 for (var rz in rzList) {
 final worklogBatch = db.batch();
 for (var log in rz.worklog ?? <Worklog>[]) {
 print('inserting rz comment ${log.description}');
 log.wonum = rz.wonum;
 worklogBatch.insert(
 Worklog.worklogTable,
 log.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await worklogBatch.commit();
 batch.insert(
 WorkTaskMobile.rzTable,
 rz.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await batch.commit();
}
Future<void> deleteRz(String wonum) async {
 await deleteCommentsByWonum(wonum);
 await deleteImagesByWonums(WorkTaskMobile.imagesTable, [wonum]);
 await db.rawQuery(
 'DELETE FROM ${WorkTaskMobile.rzTable} WHERE wonum = "$wonum"',
 );
}
Future<void> deleteAllRz(List<String> wonums) async {
 await deleteAllWorklog(wonums);
 await deleteImagesByWonums(WorkTaskMobile.imagesTable, wonums);
 await db.rawQuery('DELETE FROM ${WorkTaskMobile.rzTable}');
}
Future<Iterable<String>> readPreAcceptedRzWonums() async {
 const query = 'SELECT wonum FROM ${WorkTaskMobile.rzTable} '
 'WHERE status = "$statusPreApproved" OR status = "$statusDefecting"';
 final List<Map<String, dynamic>> rzWonums = await db.rawQuery(query);
 return rzWonums.map((e) => e['wonum']);
}
Future<List<WorkTaskMobile>> readAllRz() async {
 final List<Map<String, dynamic>> rzMap =
 await db.query(WorkTaskMobile.rzTable, orderBy: 'targcompdate');
 final rzList =
 rzMap.map((e) => WorkTaskMobile.fromMap(e)).toList().reversed.toList();
 for (final rz in rzList) {
 await _addImagesToWtm(rz);
 }
 return _addComments(rzList);
}
Future<List<WorkTaskMobile>> readAllReadyRzs() async {
 final allRzs = await readAllRz();
 return allRzs.where((rz) => rz.offlineScript != null).toList();
}
Future<WorkTaskMobile> readRzByWonum(String wonum) async {
 final query = ''
 'SELECT * FROM ${WorkTaskMobile.rzTable} '
 'WHERE wonum= $wonum'
 '';
 final List<Map<String, dynamic>> rzMap = (await db.rawQuery(query));
 final rz = WorkTaskMobile.fromMap(rzMap.first);
 if (rz.assetnum != null) {
 final asset = await readAssetByAssetnum(rz.assetnum!);
 rz.asset = asset;
 }
 final List<Worklog> comments = await readWorklogByWonum(rz.wonum ?? '');
 rz.worklog = comments;
 await _addImagesToWtm(rz);
 return rz;
}
Future<void> insertAssets(List<Asset> assets) async {
 final batch = db.batch();
 for (var a in assets) {
 batch.insert(
 Asset.assetsTable,
 a.toMap(),
 conflictAlgorithm: ConflictAlgorithm.replace,
 );
 }
 await batch.commit();
}
Future<List<Asset>> readAssets() async {
 final List<Map<String, dynamic>> assetsMap =
 await db.query(Asset.assetsTable);
 final assets =
 assetsMap.map((e) => Asset.fromMap(e)).toList().reversed.toList();
 return assets;
}
Future<void> updateRzAssetnum({
 required String wonum,
 required String assetnum,
}) async {
 await db.rawQuery(
 'UPDATE ${WorkTaskMobile.rzTable} '
 'SET assetnum = "$assetnum" '
 'WHERE wonum = "$wonum"',
 );
}
Future<void> updateRzOfflineScript({
 required String wonum,
 required String script,
}) async {
 await db.rawQuery(
 'UPDATE ${WorkTaskMobile.rzTable} '
 'SET offlineScript = "$script" '
 'WHERE wonum = "$wonum"',
 );
}
Future<void> removeRzOfflineScript({
 required String wonum,
}) async {
 await db.rawQuery(
 'UPDATE ${WorkTaskMobile.rzTable} '
 'SET offlineScript = NULL '
 'WHERE wonum = "$wonum"',
 );
}
Future<void> updateRzStatus({
 required String wonum,
 required String status,
 required String statusDescription,
}) async {
 await db.rawQuery(
 'UPDATE ${WorkTaskMobile.rzTable} '
 'SET status = "$status", status_description = "$statusDescription"'
 'WHERE wonum = "$wonum"',
 );
}
Future<Asset?> readAssetByAssetnum(String assetnum) async {
 final query = ''
 'SELECT * FROM ${Asset.assetsTable} '
 'WHERE assetnum = "$assetnum"'
 '';
 try {
 final List<Map<String, dynamic>> assetMap = (await db.rawQuery(query));
 return Asset.fromMap(assetMap.first);
 } catch (err) {
 debugPrint('cannot read asset by assetnum: $assetnum');
 return null;
 }
}
Future<void> insertSr(Sr sr) async {
 final batch = db.batch();
 batch.insert(Sr.srTable, sr.toMap());
 await batch.commit();
}
Future<void> deleteSr({
 required Sr sr,
}) async {
 if (sr.ticketid != null && (sr.ticketid?.isNotEmpty ?? false)) {
 await db.rawQuery('DELETE FROM ${Sr.srTable} WHERE '
 'ticketid = "${sr.ticketid}"');
 } else {
 await deleteSrByDescriptions(sr: sr);
 }
}
Future<void> deleteSrByDescriptions({
 required Sr sr,
}) async {
 await db.rawQuery('DELETE FROM ${Sr.srTable} WHERE '
 'description = "${sr.description}" AND locdesc = "${sr.locdesc}"');
}
Future<List<Sr>> readAllSr() async {
 final List<Map<String, dynamic>> srMap = await db.query(
 Sr.srTable,
 );
 final srList = srMap.map((e) => Sr.fromMap(e)).toList();
 for (final sr in srList) {
 _addImagesToSr(sr);
 }
 return srList;
}
Future<Sr> _addImagesToSr(Sr sr) async {
 final List<String> images =
 await readImagesPaths(wonum: sr.changedate!, forSending: false);
 if (images.isNotEmpty) {
 sr.addImages(images);
 }
 return sr;
}
Future<List<Sr>> readSavedSr() async {
 return (await readAllSr()).where((sr) => sr.ticketid == null).toList();
}
```

## File: lib/data/local_storages/shared_prefs.dart
```dart
import 'dart:convert';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/data/models/claims/site_respose.dart';
class PrefsKey {
 static const creds = 'creds';
 static const user = 'user';
 static const dev = 'dev';
 static const host = 'host';
 static const sites = 'sites';
}
void saveHost(String url) {
 prefs.setString(PrefsKey.host, url);
}
String? readHost() {
 return prefs.getString(PrefsKey.host);
}
void saveSites(SitesResponse sites) {
 final sitesMap = sites.toJson();
 prefs.setString(PrefsKey.sites, jsonEncode(sitesMap));
}
List<Site> readSites() {
 final sitesString = prefs.getString(PrefsKey.sites);
 if (sitesString == null) return [];
 final sites = SitesResponse.fromJson(jsonDecode(sitesString));
 return sites.member;
}
bool get areSitesLoaded => readSites().isNotEmpty;
void saveDev(bool dev) {
 prefs.setBool(PrefsKey.dev, dev);
}
bool isDev() {
 final dev = prefs.getBool(PrefsKey.dev);
 return dev ?? false;
}
```

## File: lib/data/maximo_repository.dart
```dart
import 'dart:io';
import 'dart:typed_data';
import 'package:dio/dio.dart';
import 'package:flutter/cupertino.dart';
import 'package:inspector_tps/core/api/endpoints.dart';
import 'package:inspector_tps/core/api/maximo_session.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/models/audit/check_list_wo.dart';
import 'package:inspector_tps/data/models/audit/rs_defect_comment.dart';
import 'package:inspector_tps/data/models/claims/site_respose.dart';
import 'package:inspector_tps/data/models/claims/sr.dart';
import 'package:inspector_tps/data/models/ppr/woactivity.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
import 'package:inspector_tps/data/models/work_task_mobile/wtm_response.dart';
base class MaximoRepository {
 final MaximoSession _session;
 MaximoRepository(this._session);
 Future<WtmResponse?> downloadAudits() async {
 final user = appStore.state.userState.user;
 final url = Endpoints.downloadAudits(
 siteId: _getSiteId(user),
 workType: _getAuditWorkType(user),
 );
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 try {
 final audit = WtmResponse.fromJson(response.data);
 return audit;
 } catch (ex) {
 debugPrint('download audits error: $ex');
 return null;
 }
 }
 return null;
 }
 String _getAuditWorkType(UserModel? user) {
 final userGroups = user?.userGroups ?? [];
 if (userGroups.contains(bdd)) {
 return '["ФНА","ФМА"]';
 }
 if (userGroups.contains(hoemp)) {
 return '["КВОСМ"]';
 }
 if (user?.isItr ?? false) {
 return '["ФНА"]';
 }
 return '["NA"]';
 }
 String? _getSiteId(UserModel? user) {
 if (user?.userGroups?.contains(hoemp) ?? false) {
 return null;
 }
 return user?.defaultSite ?? '';
 }
 Future<List<ChecklistWo>?> downloadAuditChecklists(String href) async {
 final url = '$href${Endpoints.selectChecklistwo}';
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 try {
 final data = response.data as Map<String, dynamic>;
 final chlwo = data['checklistwo'] as List<dynamic>;
 final List<ChecklistWo> checkLists = [];
 for (var e in chlwo) {
 final map = e as Map<String, dynamic>;
 final elem = ChecklistWo.fromJson(map);
 checkLists.add(elem);
 }
 return checkLists;
 } catch (ex) {
 debugPrint('download audit error: $url\n$ex');
 return null;
 }
 }
 return null;
 }
 Future<bool> updateChecklistWo({
 required String url,
 String? comment,
 String? status,
 bool? checked,
 double? factor,
 }) async {
 final updateObject = {
 if (comment != null) "goal": comment,
 if (status != null) "chliststatus": status,
 if (checked != null) "rs_masterpoint": checked,
 if (factor != null) "numberof": factor,
 };
 final Response response = await _session.post(
 url,
 headers: {
 'x-method-override': 'PATCH',
 'properties': '*',
 },
 data: updateObject,
 );
 return response.statusCode == 200;
 }
 Future<String?> getWoHref(int id) async {
 final url =
 '$baseUrlOslcOs${Endpoints.checklistWo}?oslc.where=checklistwoid=$id';
 await userController.checkAuthorization();
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 final data = response.data;
 final member = data['member'] as List<dynamic>;
 final href = member.first['href'];
 return href;
 }
 return null;
 }
 Future<void> uploadImagesToMaximo({
 required List<String> paths,
 required String docLink,
 required String table,
 }) async {
 for (String path in paths) {
 await _uploadImageAttachmentToMaximoResource(path, docLink, table);
 }
 }
 Future<void> _uploadImageAttachmentToMaximoResource(
 String path, String docLink, String table) async {
 var file = File(path);
 if (await file.exists()) {
 final Uint8List data = file.readAsBytesSync();
 var filename = path.split('/').last;
 _session.setFileNameHeader(filename);
 final Response response =
 await _session.post(docLink, data: data, headers: {
 'Content-type': 'image/png',
 'x-document-meta': 'Attachments',
 'slug': filename,
 });
 debugPrint(
 'upload image response: ${response.statusCode} ${response.statusMessage}');
 if (response.statusCode == 201) {
 await markImageAsSent(path, table);
 }
 }
 }
 Future<bool> createRsDefectCommentForChecklistWo({
 required RsDefectComment rsComment,
 }) async {
 const url = Endpoints.createRsDefectComment;
 final payload = '''
 {"checklistoperationid": ${rsComment.checklistOperationId},
 "comment": "${rsComment.comment}",
 "orgid": "TPS",
 "notcreatesr": true,
 "wonum": "${rsComment.woNum}",
 "checklistwoid": ${rsComment.checklistWoId},
 "siteid": "${rsComment.siteId}"}
 ''';
 debugPrint('creating RsDefectComment url: $url\n$payload');
 Response? response;
 try {
 response = await _session.post(
 url,
 data: payload,
 );
 debugPrint(
 'create RsDefectComment response headers: ${response?.headers} status code: ${response?.statusCode}');
 if (response?.statusCode == 201) {
 return true;
 } else {
 return false;
 }
 } catch (err) {
 debugPrint('create RsComment error: $err');
 return false;
 }
 }
 Future<WtmResponse?> downloadPprs({required String date}) async {
 final user = appStore.state.userState.user;
 final url = Endpoints.downloadPpr(
 siteId: _getSiteId(user),
 date: date,
 pprStatuses: _getPprStatuses(user));
 debugPrint(url);
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 try {
 final wtmResponse = WtmResponse.fromJson(response.data);
 return wtmResponse;
 } catch (ex) {
 debugPrint('download ppr error: $ex');
 return null;
 }
 }
 return null;
 }
 String _getPprStatuses(UserModel? user) {
 if (user?.isItrAndDutyEng ?? false) {
 return '["$statusApproved","$statusAssigned","$statusRejected","$statusCompleted"]';
 } else if (user?.isItr ?? false) {
 return '["$statusCompleted"]';
 }
 if (user?.isFilManager ?? false) {
 return '["$statusPreApproved"]';
 }
 return '["$statusApproved","$statusAssigned","$statusRejected"]';
 }
 Future<WtmResponse?> downloadWtmByWonum(String wonum) async {
 final url = Endpoints.downloadPprByWonum(wonum);
 debugPrint(url);
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 try {
 final wtmResponse = WtmResponse.fromJson(response.data);
 return wtmResponse;
 } catch (ex) {
 debugPrint('download WTM error: $ex');
 return null;
 }
 }
 return null;
 }
 Future<bool> runScript(
 String wonum, {
 required String script,
 String description = '',
 }) async {
 final url = '${Endpoints.script}/$script?VAL=$wonum';
 try {
 final response = await _session.get(url);
 if (response.statusCode == 200) {
 debugPrint('$wonum $description');
 }
 } catch (ex) {
 debugPrint('$description error: $ex');
 return false;
 }
 return true;
 }
 Future<bool> addCommentToWorkTaskMobile(String link, String comment) async {
 _session.setHeadersForUpdatingInnerObject();
 final payload = '{"worklog": [{"description": "$comment"}]}';
 print(link);
 Response? response;
 try {
 response = await _session.post(
 link,
 data: payload,
 headers: {
 'x-method-override': 'PATCH',
 'patchtype': 'MERGE',
 'properties': '*',
 },
 );
 } catch (err) {
 debugPrint('send comment error: $err');
 return false;
 }
 print('response: $response');
 return response?.statusCode == 200;
 }
 Future<bool> updateWoactivity(Woactivity job) async {
 final updateObject = {
 if (job.pprcomment != null && job.pprcomment!.isNotEmpty)
 "pprcomment": '${job.pprcomment}',
 "pprresult": job.pprresult,
 };
 final Response response = await _session.post(
 await getTestwoactivityHref(job) ?? '',
 headers: {
 'x-method-override': 'PATCH',
 'properties': '*',
 },
 data: updateObject,
 );
 print('update woactivity response: $response');
 return response.statusCode == 200;
 }
 String _generateLink(Woactivity job) {
 final link = '$baseUrlOslcOs/ilcwoactivity?lean=1&oslc.where=parent%3D%22'
 '${job.wonum}%22%20and%20taskid%3D${job.taskid}';
 return link;
 }
 Future<String?> getTestwoactivityHref(Woactivity job) async {
 await userController.checkAuthorization();
 final Response response = await _session.get(_generateLink(job));
 if (response.statusCode == 200) {
 final data = response.data;
 final member = data['member'] as List<dynamic>;
 final href = member.first['href'];
 return href;
 }
 return null;
 }
 Future<WtmResponse?> downloadRzList() async {
 final user = appStore.state.userState.user;
 final url = Endpoints.downloadRzList(siteId: _getSiteId(user));
 debugPrint(url);
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 try {
 final wtmResponse = WtmResponse.fromJson(response.data);
 return wtmResponse;
 } catch (ex) {
 debugPrint('download rz list error: $ex');
 return null;
 }
 }
 return null;
 }
 Future<bool> uploadAssetnumToWorkTaskMobile(
 String link, String assetNum) async {
 _session.setHeadersForUpdatingInnerObject();
 final payload = '{"assetnum": "$assetNum"}';
 print('update assetnum link: ${link}');
 Response? response;
 try {
 response = await _session.post(
 link,
 data: payload,
 headers: {
 'x-method-override': 'PATCH',
 'patchtype': 'MERGE',
 'properties': '*',
 },
 );
 } catch (err) {
 debugPrint('update assetnum link error: $err');
 return false;
 }
 print('update assetnum link response: $response');
 return response?.statusCode == 200;
 }
 Future<List<dynamic>?> downloadAssetsCatalog() async {
 final user = appStore.state.userState.user;
 final url = Endpoints.downloadAssetsCatalog(siteId: _getSiteId(user));
 debugPrint(url);
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 try {
 final member = response.data['member'] as List<dynamic>;
 return member;
 } catch (ex) {
 debugPrint('download assets catalog error: $ex');
 return null;
 }
 }
 return null;
 }
 Future<SitesResponse?> downloadSites() async {
 const url = Endpoints.downloadSites;
 debugPrint(url);
 final Response response = await _session.get(url);
 if (response.statusCode == 200) {
 try {
 final sitesResponse = SitesResponse.fromJson(response.data);
 return sitesResponse;
 } catch (ex) {
 debugPrint('download sites error: $ex');
 return null;
 }
 }
 return null;
 }
 Future<Sr?> createSr({
 required String location,
 required String description,
 required String siteId,
 }) async {
 const url = Endpoints.createSr;
 final user = appStore.state.userState.user;
 final payload = '''
 {
 "class": "SR",
 "repcat": "9",
 "type": "8",
 "description": "$description",
 "targetdesc": "${user?.userRole ?? (user?.defaultSite ?? '')}",
 "fromwho": "${user?.displayName ?? (user?.personId ?? '')}",
 "locdesc": "$location",
 "reportedpriority": 3,
 "siteid": "$siteId",
 "classstructureid": "1869"}
 ''';
 debugPrint('creating SR url: $url\n$payload');
 Response? response;
 try {
 response = await _session.post(
 url,
 data: payload,
 );
 if (response?.statusCode == 201) {
 final createdSrLink = response?.headers['location']?.first;
 print('created sr link: $createdSrLink');
 if (createdSrLink != null && createdSrLink.isNotEmpty) {
 final createdSrResponse = await _session.get(createdSrLink);
 final sr = Sr.fromJson(createdSrResponse.data);
 return sr;
 }
 }
 } catch (err) {
 debugPrint('create SR error: $err');
 return null;
 }
 debugPrint(
 'response headers: ${response?.headers} status code: ${response?.statusCode}');
 return null;
 }
}
```

## File: lib/data/models/audit/check_list_wo.dart
```dart
import 'package:inspector_tps/data/models/audit/checklistoperation.dart';
import 'package:inspector_tps/data/models/audit/doc_links.dart';
import 'package:inspector_tps/data/models/audit/rs_defect_comment.dart';
import 'package:json_annotation/json_annotation.dart';
part 'check_list_wo.g.dart';
@JsonSerializable()
class ChecklistWo {
 @JsonKey(name: 'rs_agr')
 final bool? rsAgr;
 @JsonKey(name: 'checklistoperationid')
 final int? checklistOperationId;
 @JsonKey(name: 'locations_collectionref')
 final String? locationsCollectionRef;
 @JsonKey(name: 'rs_mpactive')
 final bool? rsMpactive;
 @JsonKey(name: 'ipc_ticketscount')
 final String? ipcTicketscount;
 @JsonKey(name: 'orderbynumber')
 final int? orderbyNumber;
 @JsonKey(name: 'parentid')
 final int? parentId;
 @JsonKey(name: 'chliststatus')
 final String? chlistStatus;
 @JsonKey(name: 'wonum')
 final String? woNum;
 @JsonKey(name: 'countlevel')
 final int? countLevel;
 @JsonKey(name: 'haschildren')
 final bool? hasChildren;
 @JsonKey(name: 'checklistwoid')
 final int? checklistWoId;
 final String? description;
 @JsonKey(name: 'siteid')
 final String? siteId;
 @JsonKey(name: 'rs_masterpoint')
 final bool? rsMasterpoint;
 final bool? skanned;
 final String? href;
 @JsonKey(name: 'jpnum')
 final String? jpNum;
 @JsonKey(name: 'rs_defectcomment_collectionref')
 final String? rsDefectcommentCollectionRef;
 final String? localref;
 final String? number;
 final String? goal;
 final String? classid;
 @JsonKey(name: 'rs_qtypoint')
 final bool? rsQtypoint;
 @JsonKey(fromJson: DocLinks.fromJson)
 final DocLinks? doclinks;
 final List<Checklistoperation>? checklistoperation;
 @JsonKey(name: 'rs_defectcomment')
 List<RsDefectComment>? rsDefectcomment;
 final double? numberof;
 @JsonKey(name: 'ipc_hasdiag')
 final bool? ipcHasdiag;
 final bool? changed;
 bool? visited;
 final List<ChecklistWo> checklist = [];
 final List<String> images = [];
 void addImages(List<String> paths) {
 images.addAll(paths);
 }
 void removeImage(String path) {
 images.remove(path);
 }
 bool get hasFactor => checklistoperation?.first.usingfweight ?? false;
 ChecklistWo({
 this.rsAgr,
 this.checklistOperationId,
 this.locationsCollectionRef,
 this.rsMpactive,
 this.ipcTicketscount,
 this.orderbyNumber,
 this.parentId,
 this.chlistStatus,
 this.woNum,
 this.countLevel,
 this.hasChildren,
 this.checklistWoId,
 this.description,
 this.siteId,
 this.rsMasterpoint,
 this.skanned,
 this.href,
 this.jpNum,
 this.rsDefectcommentCollectionRef,
 this.localref,
 this.number,
 this.goal,
 this.classid,
 this.rsQtypoint,
 this.ipcHasdiag,
 this.changed,
 this.visited,
 this.doclinks,
 this.checklistoperation,
 this.rsDefectcomment,
 this.numberof,
 });
 factory ChecklistWo.fromJson(Map<String, dynamic> json) =>
 _$ChecklistWoFromJson(json);
 Map<String, dynamic> toJson() => _$ChecklistWoToJson(this);
 static const statusMap = {
 0: 'Нет (ведутся работы)',
 1: 'Нет',
 2: 'Да',
 4: 'Не применяется',
 };
 static const statusDescriptionMap = {
 'Нет (ведутся работы)': '0',
 'Нет': '1',
 'Да': '2',
 'Не применяется': '4',
 };
 Map<String, dynamic> toMap() {
 return {
 'rs_agr': rsAgr == null ? null : (rsAgr! ? 1 : 0),
 'checklistoperationid': checklistOperationId,
 'locations_collectionref': locationsCollectionRef,
 'rs_mpactive': rsMpactive == null ? null : (rsMpactive! ? 1 : 0),
 'ipc_ticketscount': ipcTicketscount,
 'orderbynumber': orderbyNumber,
 'parentid': parentId,
 'wonum': woNum,
 'countlevel': countLevel,
 'haschildren': hasChildren == null ? null : (hasChildren! ? 1 : 0),
 'checklistwoid': checklistWoId,
 'description': description,
 'siteid': siteId,
 'rs_masterpoint': rsMasterpoint == null ? null : (rsMasterpoint! ? 1 : 0),
 'skanned': skanned == null ? null : (skanned! ? 1 : 0),
 'href': href,
 'jpnum': jpNum,
 'rs_defectcomment_collectionref': rsDefectcommentCollectionRef,
 'localref': localref,
 'number': number,
 'numberof': numberof,
 'goal': goal,
 'classid': classid,
 'rs_qtypoint': rsQtypoint == null ? null : (rsQtypoint! ? 1 : 0),
 'chliststatus': chlistStatus,
 'ipc_hasdiag': ipcHasdiag == null ? null : (ipcHasdiag! ? 1 : 0),
 'changed': changed == null ? null : (changed! ? 1 : 0),
 'visited': visited == null ? null : (visited! ? 1 : 0),
 'doclinks': doclinks?.href,
 'usingfweight': checklistoperation?.first.usingfweight == null
 ? 0
 : (checklistoperation!.first.usingfweight! ? 1 : 0),
 };
 }
 static ChecklistWo fromMap(Map<String, dynamic> map) {
 final checklistoperation = map['usingfweight'] == null
 ? null
 : [Checklistoperation(usingfweight: (map['usingfweight'] == 1))];
 return ChecklistWo(
 rsAgr: map['rs_agr'] == null ? null : (map['rs_agr'] == 1),
 checklistOperationId: map['checklistoperationid'],
 locationsCollectionRef: map['locations_collectionref'],
 rsMpactive: map['rs_mpactive'] == null ? null : (map['rs_mpactive'] == 1),
 ipcTicketscount: map['ipc_ticketscount'],
 orderbyNumber: map['orderbynumber'],
 parentId: map['parentid'],
 woNum: map['wonum'],
 countLevel: map['countlevel'],
 hasChildren:
 map['haschildren'] == null ? null : (map['haschildren'] == 1),
 checklistWoId: map['checklistwoid'],
 description: map['description'],
 siteId: map['siteid'],
 rsMasterpoint:
 map['rs_masterpoint'] == null ? null : (map['rs_masterpoint'] == 1),
 skanned: map['skanned'] == null ? null : (map['skanned'] == 1),
 href: map['href'],
 jpNum: map['jpnum'],
 rsDefectcommentCollectionRef: map['rs_defectcomment_collectionref'],
 localref: map['localref'],
 number: map['number'],
 numberof: map['numberof'],
 goal: map['goal'],
 classid: map['classid'],
 rsQtypoint: map['rs_qtypoint'] == null ? null : (map['rs_qtypoint'] == 1),
 chlistStatus: map['chliststatus'],
 ipcHasdiag: map['ipc_hasdiag'] == null ? null : (map['ipc_hasdiag'] == 1),
 changed: map['changed'] == null ? null : (map['changed'] == 1),
 visited: map['visited'] == null ? null : (map['visited'] == 1),
 doclinks: DocLinks(href: map['doclinks']),
 checklistoperation: checklistoperation,
 );
 }
 static const checkListWoTable = 'CheckListWo';
 static const createTable = '''
 CREATE TABLE $checkListWoTable (
 rs_agr INTEGER, -- SQLite uses INTEGER for Boolean
 checklistoperationid INTEGER,
 locations_collectionref TEXT,
 rs_mpactive INTEGER, -- SQLite uses INTEGER for Boolean
 ipc_ticketscount TEXT,
 orderbynumber INTEGER,
 parentid INTEGER,
 chliststatus_description TEXT,
 wonum TEXT,
 countlevel INTEGER,
 rowstamp TEXT,
 haschildren INTEGER, -- SQLite uses INTEGER for Boolean
 checklistwoid INTEGER PRIMARY KEY, -- checklistWoId is the primary key
 description TEXT,
 -- doclinks TEXT, -- Assuming you are storing JSON as text or just the href from DocLinks
 siteid TEXT,
 rs_masterpoint INTEGER, -- SQLite uses INTEGER for Boolean
 skanned INTEGER, -- SQLite uses INTEGER for Boolean
 href TEXT,
 doclinks TEXT,
 jpnum TEXT,
 rs_defectcomment_collectionref TEXT,
 localref TEXT,
 number TEXT,
 numberof REAL,
 goal TEXT,
 classid TEXT,
 rs_qtypoint INTEGER,
 chliststatus TEXT,
 ipc_hasdiag INTEGER,
 changed INTEGER,
 visited INTEGER,
 usingfweight INTEGER 
 );
 ''';
 static const chlwoImagesTable = 'chlwoImagesTable';
 static const createChlwoImagesTable = '''
 CREATE TABLE $chlwoImagesTable (
 wonum TEXT,
 checklistwoid INTEGER,
 path TEXT PRIMARY KEY,
 sent INTEGER 
 );
 ''';
}
```

## File: lib/data/models/audit/check_list_wo.g.dart
```dart
part of 'check_list_wo.dart';
ChecklistWo _$ChecklistWoFromJson(Map<String, dynamic> json) => ChecklistWo(
 rsAgr: json['rs_agr'] as bool?,
 checklistOperationId: (json['checklistoperationid'] as num?)?.toInt(),
 locationsCollectionRef: json['locations_collectionref'] as String?,
 rsMpactive: json['rs_mpactive'] as bool?,
 ipcTicketscount: json['ipc_ticketscount'] as String?,
 orderbyNumber: (json['orderbynumber'] as num?)?.toInt(),
 parentId: (json['parentid'] as num?)?.toInt(),
 chlistStatus: json['chliststatus'] as String?,
 woNum: json['wonum'] as String?,
 countLevel: (json['countlevel'] as num?)?.toInt(),
 hasChildren: json['haschildren'] as bool?,
 checklistWoId: (json['checklistwoid'] as num?)?.toInt(),
 description: json['description'] as String?,
 siteId: json['siteid'] as String?,
 rsMasterpoint: json['rs_masterpoint'] as bool?,
 skanned: json['skanned'] as bool?,
 href: json['href'] as String?,
 jpNum: json['jpnum'] as String?,
 rsDefectcommentCollectionRef:
 json['rs_defectcomment_collectionref'] as String?,
 localref: json['localref'] as String?,
 number: json['number'] as String?,
 goal: json['goal'] as String?,
 classid: json['classid'] as String?,
 rsQtypoint: json['rs_qtypoint'] as bool?,
 ipcHasdiag: json['ipc_hasdiag'] as bool?,
 changed: json['changed'] as bool?,
 visited: json['visited'] as bool?,
 doclinks: DocLinks.fromJson(json['doclinks'] as Map<String, dynamic>),
 checklistoperation: (json['checklistoperation'] as List<dynamic>?)
 ?.map((e) => Checklistoperation.fromJson(e as Map<String, dynamic>))
 .toList(),
 rsDefectcomment: (json['rs_defectcomment'] as List<dynamic>?)
 ?.map((e) => RsDefectComment.fromJson(e as Map<String, dynamic>))
 .toList(),
 numberof: (json['numberof'] as num?)?.toDouble(),
 );
Map<String, dynamic> _$ChecklistWoToJson(ChecklistWo instance) =>
 <String, dynamic>{
 'rs_agr': instance.rsAgr,
 'checklistoperationid': instance.checklistOperationId,
 'locations_collectionref': instance.locationsCollectionRef,
 'rs_mpactive': instance.rsMpactive,
 'ipc_ticketscount': instance.ipcTicketscount,
 'orderbynumber': instance.orderbyNumber,
 'parentid': instance.parentId,
 'chliststatus': instance.chlistStatus,
 'wonum': instance.woNum,
 'countlevel': instance.countLevel,
 'haschildren': instance.hasChildren,
 'checklistwoid': instance.checklistWoId,
 'description': instance.description,
 'siteid': instance.siteId,
 'rs_masterpoint': instance.rsMasterpoint,
 'skanned': instance.skanned,
 'href': instance.href,
 'jpnum': instance.jpNum,
 'rs_defectcomment_collectionref': instance.rsDefectcommentCollectionRef,
 'localref': instance.localref,
 'number': instance.number,
 'goal': instance.goal,
 'classid': instance.classid,
 'rs_qtypoint': instance.rsQtypoint,
 'doclinks': instance.doclinks,
 'checklistoperation': instance.checklistoperation,
 'rs_defectcomment': instance.rsDefectcomment,
 'numberof': instance.numberof,
 'ipc_hasdiag': instance.ipcHasdiag,
 'changed': instance.changed,
 'visited': instance.visited,
 };
```

## File: lib/data/models/audit/checklistoperation.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'checklistoperation.g.dart';
@JsonSerializable()
class Checklistoperation {
 final bool? usingfweight;
 Checklistoperation({this.usingfweight});
 factory Checklistoperation.fromJson(Map<String, dynamic> json) =>
 _$ChecklistoperationFromJson(json);
 Map<String, dynamic> toJson() => _$ChecklistoperationToJson(this);
}
```

## File: lib/data/models/audit/checklistoperation.g.dart
```dart
part of 'checklistoperation.dart';
Checklistoperation _$ChecklistoperationFromJson(Map<String, dynamic> json) =>
 Checklistoperation(
 usingfweight: json['usingfweight'] as bool?,
 );
Map<String, dynamic> _$ChecklistoperationToJson(Checklistoperation instance) =>
 <String, dynamic>{
 'usingfweight': instance.usingfweight,
 };
```

## File: lib/data/models/audit/doc_links.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'doc_links.g.dart';
@JsonSerializable()
class DocLinks {
 final String? href;
 DocLinks({this.href});
 factory DocLinks.fromJson(Map<String, dynamic> json) =>
 _$DocLinksFromJson(json);
 Map<String, dynamic> toJson() => _$DocLinksToJson(this);
}
```

## File: lib/data/models/audit/doc_links.g.dart
```dart
part of 'doc_links.dart';
DocLinks _$DocLinksFromJson(Map<String, dynamic> json) => DocLinks(
 href: json['href'] as String?,
 );
Map<String, dynamic> _$DocLinksToJson(DocLinks instance) => <String, dynamic>{
 'href': instance.href,
 };
```

## File: lib/data/models/audit/rs_defect_comment.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'rs_defect_comment.g.dart';
@JsonSerializable()
class RsDefectComment {
 @JsonKey(name: 'checklistoperationid')
 final int? checklistOperationId;
 @JsonKey(name: 'comment')
 final String? comment;
 @JsonKey(name: 'orgid')
 final String? orgId;
 @JsonKey(name: 'notcreatesr')
 final bool? notCreateSr;
 @JsonKey(name: 'wonum')
 String? woNum;
 @JsonKey(name: 'checklistwoid')
 final int? checklistWoId;
 @JsonKey(name: 'siteid')
 final String? siteId;
 @JsonKey(name: 'rs_defectcommentid')
 final int? rsDefectCommentId;
 @JsonKey(name: 'href')
 final String? href;
 RsDefectComment({
 this.checklistOperationId,
 this.comment,
 this.orgId,
 this.notCreateSr,
 this.woNum,
 this.checklistWoId,
 this.siteId,
 this.rsDefectCommentId,
 this.href,
 });
 factory RsDefectComment.fromJson(Map<String, dynamic> json) =>
 _$RsDefectCommentFromJson(json);
 Map<String, dynamic> toJson() => _$RsDefectCommentToJson(this);
 static RsDefectComment fromMap(Map<String, dynamic> map) {
 return RsDefectComment(
 checklistOperationId: map['checklistoperationid'] as int?,
 comment: map['comment'] as String?,
 orgId: map['orgid'] as String?,
 notCreateSr: map['notcreatesr'] == 1,
 woNum: map['wonum'] as String?,
 checklistWoId: map['checklistwoid'] as int?,
 siteId: map['siteid'] as String?,
 rsDefectCommentId: map['rs_defectcommentid'] as int?,
 href: map['href'] as String?,
 );
 }
 Map<String, dynamic> toMap() {
 return {
 'checklistoperationid': checklistOperationId,
 'comment': comment,
 'orgid': orgId,
 'notcreatesr': notCreateSr == true ? 1 : 0,
 'wonum': woNum,
 'checklistwoid': checklistWoId,
 'siteid': siteId,
 'rs_defectcommentid': rsDefectCommentId,
 'href': href,
 };
 }
 static const commentsTable = 'commentsTable';
 static const createTable = '''
 CREATE TABLE $commentsTable (
 checklistoperationid INTEGER,
 comment TEXT,
 orgid TEXT,
 notcreatesr INTEGER,
 wonum TEXT,
 checklistwoid INTEGER,
 siteid TEXT,
 rs_defectcommentid INTEGER,
 href TEXT
 );
 ''';
}
```

## File: lib/data/models/audit/rs_defect_comment.g.dart
```dart
part of 'rs_defect_comment.dart';
RsDefectComment _$RsDefectCommentFromJson(Map<String, dynamic> json) =>
 RsDefectComment(
 checklistOperationId: (json['checklistoperationid'] as num?)?.toInt(),
 comment: json['comment'] as String?,
 orgId: json['orgid'] as String?,
 notCreateSr: json['notcreatesr'] as bool?,
 woNum: json['wonum'] as String?,
 checklistWoId: (json['checklistwoid'] as num?)?.toInt(),
 siteId: json['siteid'] as String?,
 rsDefectCommentId: (json['rs_defectcommentid'] as num?)?.toInt(),
 href: json['href'] as String?,
 );
Map<String, dynamic> _$RsDefectCommentToJson(RsDefectComment instance) =>
 <String, dynamic>{
 'checklistoperationid': instance.checklistOperationId,
 'comment': instance.comment,
 'orgid': instance.orgId,
 'notcreatesr': instance.notCreateSr,
 'wonum': instance.woNum,
 'checklistwoid': instance.checklistWoId,
 'siteid': instance.siteId,
 'rs_defectcommentid': instance.rsDefectCommentId,
 'href': instance.href,
 };
```

## File: lib/data/models/claims/site_respose.dart
```dart
class SitesResponse {
 List<Site> member;
 SitesResponse({required this.member});
 factory SitesResponse.fromJson(Map<String, dynamic> json) {
 return SitesResponse(
 member:
 (json['member'] as List).map((site) => Site.fromJson(site)).toList(),
 );
 }
 Map<String, dynamic> toJson() {
 return {
 'member': member.map((site) => site.toJson()).toList(),
 };
 }
}
class Site {
 String description;
 String value;
 Site({required this.description, required this.value});
 factory Site.fromJson(Map<String, dynamic> json) {
 return Site(
 description: json['description'],
 value: json['value'],
 );
 }
 Map<String, dynamic> toJson() {
 return {
 'description': description,
 'value': value,
 };
 }
 @override
 String toString() {
 return 'site: $value $description';
 }
}
```

## File: lib/data/models/claims/sr.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'sr.g.dart';
@JsonSerializable()
class Sr {
 final String? changedate; // use as generated wonum for images table
 final String? statusDescription;
 final String? reportedpriorityDescription;
 final String? classDescription;
 final String? type;
 final int? ticketuid;
 final String? reportdate;
 final String? orgid;
 final String? description;
 final String? typeDescription;
 final String? siteid;
 final String? href;
 final String? locdesc;
 final String? repcatDescription;
 final String? classstructureid;
 final String? statusdate;
 final String? status;
 final String? changeby;
 final String? repcat;
 final String? ticketdesc;
 final String? fromwho;
 final int? reportedpriority;
 final String? loggeduser;
 final String? targetfinish;
 final String? ticketid;
 final List<String> images = [];
 Sr({
 this.changedate,
 this.statusDescription,
 this.reportedpriorityDescription,
 this.classDescription,
 this.type,
 this.ticketuid,
 this.reportdate,
 this.orgid,
 this.description,
 this.typeDescription,
 this.siteid,
 this.href,
 this.locdesc,
 this.repcatDescription,
 this.classstructureid,
 this.statusdate,
 this.status,
 this.changeby,
 this.repcat,
 this.ticketdesc,
 this.fromwho,
 this.reportedpriority,
 this.loggeduser,
 this.targetfinish,
 this.ticketid,
 });
 factory Sr.fromJson(Map<String, dynamic> json) => _$SrFromJson(json);
 Map<String, dynamic> toJson() => _$SrToJson(this);
 bool get isLocal => ticketid == null;
 bool get sent => ticketid != null;
 void addImages(List<String> paths) {
 images.addAll(paths);
 }
 void removeImage(String path) {
 images.remove(path);
 }
 @override
 String toString() {
 return 'Sr{ticketid: "$ticketid" "$description" "$locdesc"'
 'href: $href}';
 }
 Map<String, dynamic> toMap() {
 return {
 'changedate': changedate,
 'statusDescription': statusDescription,
 'reportedpriorityDescription': reportedpriorityDescription,
 'classDescription': classDescription,
 'type': type,
 'ticketuid': ticketuid,
 'reportdate': reportdate,
 'orgid': orgid,
 'description': description,
 'typeDescription': typeDescription,
 'siteid': siteid,
 'href': href,
 'locdesc': locdesc,
 'repcatDescription': repcatDescription,
 'classstructureid': classstructureid,
 'statusdate': statusdate,
 'status': status,
 'changeby': changeby,
 'repcat': repcat,
 'ticketdesc': ticketdesc,
 'fromwho': fromwho,
 'reportedpriority': reportedpriority,
 'loggeduser': loggeduser,
 'targetfinish': targetfinish,
 'ticketid': ticketid,
 };
 }
 static Sr fromMap(Map<String, dynamic> map) {
 return Sr(
 changedate: map['changedate'] as String?,
 statusDescription: map['statusDescription'] as String?,
 reportedpriorityDescription:
 map['reportedpriorityDescription'] as String?,
 classDescription: map['classDescription'] as String?,
 type: map['type'] as String?,
 ticketuid: map['ticketuid'] as int?,
 reportdate: map['reportdate'] as String?,
 orgid: map['orgid'] as String?,
 description: map['description'] as String?,
 typeDescription: map['typeDescription'] as String?,
 siteid: map['siteid'] as String?,
 href: map['href'] as String?,
 locdesc: map['locdesc'] as String?,
 repcatDescription: map['repcatDescription'] as String?,
 classstructureid: map['classstructureid'] as String?,
 statusdate: map['statusdate'] as String?,
 status: map['status'] as String?,
 changeby: map['changeby'] as String?,
 repcat: map['repcat'] as String?,
 ticketdesc: map['ticketdesc'] as String?,
 fromwho: map['fromwho'] as String?,
 reportedpriority: map['reportedpriority'] as int?,
 loggeduser: map['loggeduser'] as String?,
 targetfinish: map['targetfinish'] as String?,
 ticketid: map['ticketid'] as String?,
 );
 }
 static const srTable = 'srTable';
 static const createSrTable = '''
 CREATE TABLE $srTable (
 ticketid TEXT,
 changedate TEXT,
 statusDescription TEXT,
 reportedpriorityDescription TEXT,
 classDescription TEXT,
 type TEXT,
 ticketuid INTEGER,
 reportdate TEXT,
 orgid TEXT,
 description TEXT,
 typeDescription TEXT,
 siteid TEXT,
 href TEXT,
 locdesc TEXT,
 repcatDescription TEXT,
 classstructureid TEXT,
 statusdate TEXT,
 status TEXT,
 changeby TEXT,
 repcat TEXT,
 ticketdesc TEXT,
 fromwho TEXT,
 reportedpriority INTEGER,
 loggeduser TEXT,
 targetfinish TEXT
);
 ''';
}
```

## File: lib/data/models/claims/sr.g.dart
```dart
part of 'sr.dart';
Sr _$SrFromJson(Map<String, dynamic> json) => Sr(
 changedate: json['changedate'] as String?,
 statusDescription: json['statusDescription'] as String?,
 reportedpriorityDescription:
 json['reportedpriorityDescription'] as String?,
 classDescription: json['classDescription'] as String?,
 type: json['type'] as String?,
 ticketuid: (json['ticketuid'] as num?)?.toInt(),
 reportdate: json['reportdate'] as String?,
 orgid: json['orgid'] as String?,
 description: json['description'] as String?,
 typeDescription: json['typeDescription'] as String?,
 siteid: json['siteid'] as String?,
 href: json['href'] as String?,
 locdesc: json['locdesc'] as String?,
 repcatDescription: json['repcatDescription'] as String?,
 classstructureid: json['classstructureid'] as String?,
 statusdate: json['statusdate'] as String?,
 status: json['status'] as String?,
 changeby: json['changeby'] as String?,
 repcat: json['repcat'] as String?,
 ticketdesc: json['ticketdesc'] as String?,
 fromwho: json['fromwho'] as String?,
 reportedpriority: (json['reportedpriority'] as num?)?.toInt(),
 loggeduser: json['loggeduser'] as String?,
 targetfinish: json['targetfinish'] as String?,
 ticketid: json['ticketid'] as String?,
 );
Map<String, dynamic> _$SrToJson(Sr instance) => <String, dynamic>{
 'changedate': instance.changedate,
 'statusDescription': instance.statusDescription,
 'reportedpriorityDescription': instance.reportedpriorityDescription,
 'classDescription': instance.classDescription,
 'type': instance.type,
 'ticketuid': instance.ticketuid,
 'reportdate': instance.reportdate,
 'orgid': instance.orgid,
 'description': instance.description,
 'typeDescription': instance.typeDescription,
 'siteid': instance.siteid,
 'href': instance.href,
 'locdesc': instance.locdesc,
 'repcatDescription': instance.repcatDescription,
 'classstructureid': instance.classstructureid,
 'statusdate': instance.statusdate,
 'status': instance.status,
 'changeby': instance.changeby,
 'repcat': instance.repcat,
 'ticketdesc': instance.ticketdesc,
 'fromwho': instance.fromwho,
 'reportedpriority': instance.reportedpriority,
 'loggeduser': instance.loggeduser,
 'targetfinish': instance.targetfinish,
 'ticketid': instance.ticketid,
 };
```

## File: lib/data/models/photo_params.dart
```dart
import 'package:inspector_tps/core/camera/camera_screen.dart';
class PhotoParams {
 final int? checklistwoid;
 final String wonum;
 final CameraMode mode;
 PhotoParams({
 this.checklistwoid,
 required this.wonum,
 required this.mode,
 });
}
```

## File: lib/data/models/ppr/asset.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'asset.g.dart';
@JsonSerializable()
class Asset {
 final String? description;
 final String? assetnum;
 String? locationDescription;
 String? classstructureDescription;
 Asset({
 this.description,
 this.assetnum,
 this.locationDescription,
 this.classstructureDescription,
 });
 factory Asset.fromJson(Map<String, dynamic> json) => _$AssetFromJson(json);
 Map<String, dynamic> toJson() => _$AssetToJson(this);
 Map<String, dynamic> toMap() {
 return {
 'description': description,
 'assetnum': assetnum,
 'locationDescription': locationDescription,
 'classstructureDescription': classstructureDescription,
 };
 }
 static Asset fromMap(Map<String, dynamic> map) {
 return Asset(
 description: map['description'] as String?,
 assetnum: map['assetnum'] as String?,
 locationDescription: map['locationDescription'] as String?,
 classstructureDescription: map['classstructureDescription'] as String?,
 );
 }
 static const assetsTable = 'assetsTable';
 static const createAssetsTable = '''
 CREATE TABLE $assetsTable (
 assetnum TEXT,
 description TEXT,
 locationDescription TEXT,
 classstructureDescription TEXT
 );
 ''';
 @override
 String toString() {
 return '${assetnum ?? ''} ${description ?? ''} ${locationDescription ?? ''}'
 ' ${classstructureDescription ?? ''}';
 }
}
```

## File: lib/data/models/ppr/asset.g.dart
```dart
part of 'asset.dart';
Asset _$AssetFromJson(Map<String, dynamic> json) => Asset(
 description: json['description'] as String?,
 assetnum: json['assetnum'] as String?,
 locationDescription: json['locationDescription'] as String?,
 classstructureDescription: json['classstructureDescription'] as String?,
 );
Map<String, dynamic> _$AssetToJson(Asset instance) => <String, dynamic>{
 'description': instance.description,
 'assetnum': instance.assetnum,
 'locationDescription': instance.locationDescription,
 'classstructureDescription': instance.classstructureDescription,
 };
```

## File: lib/data/models/ppr/location.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'location.g.dart';
@JsonSerializable()
class Location {
 final String? description;
 final String? olddescription;
 Location({this.description, this.olddescription});
 factory Location.fromJson(Map<String, dynamic> json) =>
 _$LocationFromJson(json);
 Map<String, dynamic> toJson() => _$LocationToJson(this);
}
```

## File: lib/data/models/ppr/location.g.dart
```dart
part of 'location.dart';
Location _$LocationFromJson(Map<String, dynamic> json) => Location(
 description: json['description'] as String?,
 olddescription: json['olddescription'] as String?,
 );
Map<String, dynamic> _$LocationToJson(Location instance) => <String, dynamic>{
 'description': instance.description,
 'olddescription': instance.olddescription,
 };
```

## File: lib/data/models/ppr/woactivity.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'woactivity.g.dart';
@JsonSerializable()
class Woactivity {
 String? wonum;
 final String? description;
 final String? pprcomment;
 final String? pprresult;
 final String? localref;
 final int? wosequence;
 final double? estdur;
 final int? taskid;
 factory Woactivity.fromJson(Map<String, dynamic> json) =>
 _$WoactivityFromJson(json);
 Woactivity({
 this.wonum,
 this.description,
 this.pprcomment,
 this.pprresult,
 this.wosequence,
 this.estdur,
 this.taskid,
 this.localref,
 });
 Map<String, dynamic> toJson() => _$WoactivityToJson(this);
 Map<String, dynamic> toMap() {
 return {
 'wonum': wonum,
 'description': description,
 'pprcomment': pprcomment,
 'pprresult': pprresult,
 'wosequence': wosequence,
 'estdur': estdur,
 'localref': localref,
 'taskid': taskid,
 };
 }
 static Woactivity fromMap(Map<String, dynamic> map) {
 return Woactivity(
 wonum: map['wonum'],
 description: map['description'],
 pprcomment: map['pprcomment'],
 pprresult: map['pprresult'],
 wosequence: map['wosequence'],
 estdur: map['estdur'],
 localref: map['localref'],
 taskid: map['taskid'],
 );
 }
 static const woactivityTable = 'WoactivityTable';
 static const createWoactivityTable = '''
 CREATE TABLE $woactivityTable (
 wonum TEXT,
 description TEXT,
 pprcomment TEXT,
 pprresult TEXT,
 wosequence INTEGER,
 estdur REAL,
 taskid INTEGER,
 localref TEXT 
 );
 ''';
}
```

## File: lib/data/models/ppr/woactivity.g.dart
```dart
part of 'woactivity.dart';
Woactivity _$WoactivityFromJson(Map<String, dynamic> json) => Woactivity(
 wonum: json['wonum'] as String?,
 description: json['description'] as String?,
 pprcomment: json['pprcomment'] as String?,
 pprresult: json['pprresult'] as String?,
 wosequence: (json['wosequence'] as num?)?.toInt(),
 estdur: (json['estdur'] as num?)?.toDouble(),
 taskid: (json['taskid'] as num?)?.toInt(),
 localref: json['localref'] as String?,
 );
Map<String, dynamic> _$WoactivityToJson(Woactivity instance) =>
 <String, dynamic>{
 'wonum': instance.wonum,
 'description': instance.description,
 'pprcomment': instance.pprcomment,
 'pprresult': instance.pprresult,
 'localref': instance.localref,
 'wosequence': instance.wosequence,
 'estdur': instance.estdur,
 'taskid': instance.taskid,
 };
```

## File: lib/data/models/user/user_model.dart
```dart
import 'package:inspector_tps/core/constants.dart';
import 'package:json_annotation/json_annotation.dart';
part 'user_model.g.dart';
@JsonSerializable()
class UserModel {
 String? defaultOrg;
 String? defaultSite;
 String? personId;
 String? loginID;
 String? email;
 String? displayName;
 String? userRole;
 List<String>? userGroups;
 UserModel({
 this.defaultOrg,
 this.defaultSite,
 this.personId,
 this.loginID,
 this.email,
 this.displayName,
 this.userRole,
 this.userGroups,
 });
 factory UserModel.fromJson(Map<String, dynamic> json) =>
 _$UserModelFromJson(json);
 Map<String, dynamic> toJson() => _$UserModelToJson(this);
 UserModel copyWith({
 String? defaultOrg,
 String? defaultSite,
 String? personId,
 String? loginID,
 String? email,
 String? displayName,
 String? userRole,
 List<String>? userGroups,
 }) {
 return UserModel(
 defaultOrg: defaultOrg ?? this.defaultOrg,
 defaultSite: defaultSite ?? this.defaultSite,
 personId: personId ?? this.personId,
 loginID: loginID ?? this.loginID,
 email: email ?? this.email,
 displayName: displayName ?? this.displayName,
 userRole: userRole ?? this.userRole,
 userGroups: userGroups ?? this.userGroups,
 );
 }
 bool get isFilManager {
 final List<String> groups = userGroups ?? [];
 return groups.contains(bdd) || groups.contains(hoemp);
 }
 bool get isDutyEng {
 final List<String> groups = userGroups ?? [];
 return groups.contains(dutyEngGroup);
 }
 bool get isItr {
 final List<String> groups = userGroups ?? [];
 return groups.contains(ceew);
 }
 bool get isCo {
 final List<String> groups = userGroups ?? [];
 return groups.contains(hoemp);
 }
 bool get isItrAndDutyEng => isItr && isDutyEng;
 List<int> hiddenTabs() {
 if (isDutyEng && !isItr) {
 return [0];
 }
 return [];
 }
 @override
 String toString() {
 return 'UserModel{defaultOrg: $defaultOrg, defaultSite: $defaultSite,'
 'personId: $personId, loginID: $loginID, email: $email,'
 'displayName: $displayName}, userRole: $userRole';
 }
}
```

## File: lib/data/models/user/user_model.g.dart
```dart
part of 'user_model.dart';
UserModel _$UserModelFromJson(Map<String, dynamic> json) => UserModel(
 defaultOrg: json['defaultOrg'] as String?,
 defaultSite: json['defaultSite'] as String?,
 personId: json['personId'] as String?,
 loginID: json['loginID'] as String?,
 email: json['email'] as String?,
 displayName: json['displayName'] as String?,
 userRole: json['userRole'] as String?,
 userGroups: (json['userGroups'] as List<dynamic>?)
 ?.map((e) => e as String)
 .toList(),
 );
Map<String, dynamic> _$UserModelToJson(UserModel instance) => <String, dynamic>{
 'defaultOrg': instance.defaultOrg,
 'defaultSite': instance.defaultSite,
 'personId': instance.personId,
 'loginID': instance.loginID,
 'email': instance.email,
 'displayName': instance.displayName,
 'userRole': instance.userRole,
 'userGroups': instance.userGroups,
 };
```

## File: lib/data/models/user/user_request.dart
```dart
import 'dart:convert';
class UserRequest {
 UserRequest({
 required this.identifier,
 required this.password,
 });
 String identifier;
 String password;
 Map<String, String> get headers => {
 'Authorization':
 'Basic ${base64Encode(utf8.encode('$identifier:$password'))}',
 };
}
```

## File: lib/data/models/work_task_mobile/work_task_mobile.dart
```dart
import 'package:inspector_tps/data/models/audit/doc_links.dart';
import 'package:inspector_tps/data/models/ppr/asset.dart';
import 'package:inspector_tps/data/models/ppr/location.dart';
import 'package:inspector_tps/data/models/ppr/woactivity.dart';
import 'package:inspector_tps/data/models/worklog/worklog.dart';
import 'package:json_annotation/json_annotation.dart';
part 'work_task_mobile.g.dart';
class WorkTaskMobile {
 final String? wonum;
 final String? description;
 final String? status;
 @JsonKey(name: 'status_description')
 final String? statusDescription;
 final String? targstartdate;
 final String? targcompdate;
 final String? siteid;
 final String? href;
 final String? worktype;
 final String? owner;
 @JsonKey(name: 'rs_week_description')
 final String? weekDescription;
 @JsonKey(name: 'rs_month_description')
 final String? monthDescription;
 @JsonKey(name: 'rs_quarter_description')
 final String? quarterDescription;
 @JsonKey(name: 'rs_year_description')
 final String? yearDescription;
 Asset? asset;
 final Location? location;
 @JsonKey(fromJson: DocLinks.fromJson)
 final DocLinks? doclinks;
 final String? assetnum;
 List<Woactivity>? woactivity;
 List<Worklog>? worklog;
 final bool? started;
 final bool? finished;
 final String? displayName;
 final String? reportDate;
 final String? offlineScript;
 final String? priority;
 final String? fromwho;
 final String? ticketdesc;
 final double? timeStampStarted;
 final double? timeStampFinished;
 bool pprTakenInMaximo;
 final List<String> images = [];
 void addImages(List<String> paths) {
 images.addAll(paths);
 }
 void removeImage(String path) {
 images.remove(path);
 }
 WorkTaskMobile({
 this.wonum,
 this.owner,
 this.description,
 this.status,
 this.statusDescription,
 this.targstartdate,
 this.targcompdate,
 this.siteid,
 this.href,
 this.worktype,
 this.started,
 this.finished,
 this.timeStampStarted,
 this.timeStampFinished,
 this.weekDescription,
 this.monthDescription,
 this.quarterDescription,
 this.yearDescription,
 this.asset,
 this.location,
 this.woactivity,
 this.worklog,
 this.doclinks,
 this.pprTakenInMaximo = false,
 this.priority,
 this.displayName,
 this.reportDate,
 this.fromwho,
 this.ticketdesc,
 this.assetnum,
 this.offlineScript,
 });
 bool get isKvosm => worktype == 'КВОСМ';
 factory WorkTaskMobile.fromJson(Map<String, dynamic> json) =>
 _$WorkTaskMobileFromJson(json);
 Map<String, dynamic> toJson() => _$WorkTaskMobileToJson(this);
 @override
 String toString() {
 return '$wonum $siteid $worktype $description \n'
 'status: $status $statusDescription'
 'displayname: $displayName assetnum: $assetnum '
 'owner: $owner fromWho: $fromwho priority: $priority\n'
 'start: $targstartdate reportDate: $reportDate'
 'comp: $targcompdate, takenInMaximo: $pprTakenInMaximo\n'
 'jobs: ${woactivity?.length} worklog: ${worklog?.length}\n'
 'offlineScript: $offlineScript, doclinks: ${doclinks?.href}\n'
 'href: $href';
 }
 Map<String, dynamic> toMap() {
 return {
 'wonum': wonum,
 'owner': owner,
 'fromwho': fromwho,
 'displayName': displayName,
 'description': description,
 'status_description': statusDescription,
 'status': status,
 'priority': priority,
 'targstartdate': targstartdate,
 'targcompdate': targcompdate,
 'reportDate': reportDate,
 'rs_week_description': weekDescription,
 'rs_month_description': monthDescription,
 'rs_quarter_description': quarterDescription,
 'rs_year_description': yearDescription,
 'siteid': siteid,
 'ticketdesc': ticketdesc,
 'href': href,
 'worktype': worktype,
 'started': started == null ? null : (started! ? 1 : 0),
 'finished': finished == null ? null : (finished! ? 1 : 0),
 'timeStampStarted': timeStampStarted,
 'timeStampFinished': timeStampFinished,
 assetDescription: asset?.description,
 locationDescription: location?.description,
 locationOldDescription: location?.olddescription,
 'doclinks': doclinks?.href,
 'pprTakenInMaximo': pprTakenInMaximo ? 1 : 0,
 'assetnum': assetnum,
 'offlineScript': offlineScript,
 };
 }
 static WorkTaskMobile fromMap(Map<String, dynamic> map) {
 return WorkTaskMobile(
 wonum: map['wonum'],
 owner: map['owner'],
 fromwho: map['fromwho'],
 displayName: map['displayName'],
 priority: map['priority'],
 description: map['description'],
 statusDescription: map['status_description'],
 status: map['status'],
 targstartdate: map['targstartdate'],
 targcompdate: map['targcompdate'],
 reportDate: map['reportDate'],
 weekDescription: map['rs_week_description'],
 monthDescription: map['rs_month_description'],
 quarterDescription: map['rs_quarter_description'],
 yearDescription: map['rs_year_description'],
 siteid: map['siteid'],
 ticketdesc: map['ticketdesc'],
 href: map['href'],
 worktype: map['worktype'],
 started: map['started'] == null ? null : (map['started'] == 1),
 finished: map['finished'] == null ? null : (map['finished'] == 1),
 pprTakenInMaximo: map['pprTakenInMaximo'] == 1,
 timeStampStarted: map['timeStampStarted'],
 timeStampFinished: map['timeStampFinished'],
 assetnum: map['assetnum'],
 offlineScript: map['offlineScript'],
 doclinks:
 map['doclinks'] != null ? DocLinks(href: map['doclinks']) : null,
 asset: map[assetDescription] == null
 ? null
 : Asset(description: map[assetDescription]),
 location: map[locationDescription] == null
 ? null
 : Location(
 description: map[locationDescription],
 olddescription: map[locationOldDescription]),
 );
 }
 static const auditsTable = 'WorkTaskMobile';
 static const createAuditsTable = '''
 CREATE TABLE $auditsTable (
 wonum TEXT PRIMARY KEY ,
 owner TEXT,
 fromwho TEXT,
 displayName TEXT,
 priority TEXT,
 description TEXT,
 status_description TEXT,
 status TEXT,
 targstartdate TEXT,
 targcompdate TEXT,
 reportDate TEXT,
 rs_week_description TEXT,
 rs_month_description TEXT,
 rs_quarter_description TEXT,
 rs_year_description TEXT,
 siteid TEXT,
 ticketdesc TEXT,
 href TEXT,
 doclinks TEXT,
 worktype TEXT,
 assetnum TEXT,
 offlineScript TEXT,
 $assetDescription TEXT,
 $locationDescription TEXT,
 $locationOldDescription TEXT,
 started INTEGER,
 finished INTEGER,
 pprTakenInMaximo INTEGER,
 timeStampStarted REAL,
 timeStampFinished REAL
 )''';
 static const pprTable = 'pprTable';
 static const createPprTable = '''
 CREATE TABLE $pprTable (
 wonum TEXT PRIMARY KEY ,
 owner TEXT,
 fromwho TEXT,
 displayName TEXT,
 priority TEXT,
 description TEXT,
 status TEXT,
 status_description TEXT,
 targstartdate TEXT,
 targcompdate TEXT,
 reportDate TEXT,
 rs_week_description TEXT,
 rs_month_description TEXT,
 rs_quarter_description TEXT,
 rs_year_description TEXT,
 siteid TEXT,
 ticketdesc TEXT,
 href TEXT,
 doclinks TEXT,
 worktype TEXT,
 assetnum TEXT,
 offlineScript TEXT,
 $assetDescription TEXT,
 $locationDescription TEXT,
 $locationOldDescription TEXT,
 started INTEGER,
 finished INTEGER,
 pprTakenInMaximo INTEGER,
 timeStampStarted REAL,
 timeStampFinished REAL
 )''';
 static const imagesTable = 'imagesTable';
 static const createImagesTable = '''
 CREATE TABLE $imagesTable (
 wonum TEXT,
 path TEXT PRIMARY KEY,
 sent INTEGER 
 );
 ''';
 static const rzTable = 'rzTable';
 static const createRzTable = '''
 CREATE TABLE $rzTable (
 wonum TEXT PRIMARY KEY ,
 owner TEXT,
 fromwho TEXT,
 displayName TEXT,
 priority TEXT,
 description TEXT,
 status TEXT,
 status_description TEXT,
 targstartdate TEXT,
 targcompdate TEXT,
 reportDate TEXT,
 rs_week_description TEXT,
 rs_month_description TEXT,
 rs_quarter_description TEXT,
 rs_year_description TEXT,
 siteid TEXT,
 ticketdesc TEXT,
 href TEXT,
 doclinks TEXT,
 worktype TEXT,
 assetnum TEXT,
 offlineScript TEXT,
 $assetDescription TEXT,
 $locationDescription TEXT,
 $locationOldDescription TEXT,
 started INTEGER,
 finished INTEGER,
 pprTakenInMaximo INTEGER,
 timeStampStarted REAL,
 timeStampFinished REAL
 )''';
}
const assetDescription = 'asset_description';
const locationDescription = 'location_description';
const locationOldDescription = 'location_olddescription';
```

## File: lib/data/models/work_task_mobile/work_task_mobile.g.dart
```dart
part of 'work_task_mobile.dart';
WorkTaskMobile _$WorkTaskMobileFromJson(Map<String, dynamic> json) =>
 WorkTaskMobile(
 wonum: json['wonum'] as String?,
 owner: json['owner'] as String?,
 description: json['description'] as String?,
 status: json['status'] as String?,
 statusDescription: json['status_description'] as String?,
 targstartdate: json['targstartdate'] as String?,
 targcompdate: json['targcompdate'] as String?,
 siteid: json['siteid'] as String?,
 href: json['href'] as String?,
 worktype: json['worktype'] as String?,
 assetnum: json['assetnum'] as String?,
 offlineScript: json['offlineScript'] as String?,
 started: json['started'] as bool?,
 finished: json['finished'] as bool?,
 timeStampStarted: (json['timeStampStarted'] as num?)?.toDouble(),
 timeStampFinished: (json['timeStampFinished'] as num?)?.toDouble(),
 weekDescription: json['rs_week_description'] as String?,
 monthDescription: json['rs_month_description'] as String?,
 quarterDescription: json['rs_quarter_description'] as String?,
 yearDescription: json['rs_year_description'] as String?,
 asset: json['asset'] == null
 ? null
 : Asset.fromJson(json['asset'] as Map<String, dynamic>),
 location: json['location'] == null
 ? null
 : Location.fromJson(json['location'] as Map<String, dynamic>),
 woactivity: (json['woactivity'] as List<dynamic>?)
 ?.map((e) => Woactivity.fromJson(e as Map<String, dynamic>))
 .toList(),
 worklog: (json['worklog'] as List<dynamic>?)
 ?.map((e) => Worklog.fromJson(e as Map<String, dynamic>))
 .toList(),
 doclinks: DocLinks.fromJson(json['doclinks'] as Map<String, dynamic>),
 pprTakenInMaximo: json['pprTakenInMaximo'] as bool? ?? false,
 displayName: _getDisplayName(json['person']),
 reportDate: _getReportDateSr(json['sr']),
 priority: _getPrioritySr(json['sr']),
 fromwho: _getFromWhoSr(json['sr']),
 ticketdesc: _getTicketdescSr(json['sr']),
 );
String? _getDisplayName(List<dynamic>? lst) {
 final mp = lst?.first as Map<String, dynamic>?;
 if (mp == null) return null;
 try {
 final name = mp['displayname'];
 return name;
 } catch (ex) {
 print('can not get displayname');
 return null;
 }
}
String? _getReportDateSr(List<dynamic>? lst) {
 final mp = lst?.first as Map<String, dynamic>?;
 if (mp == null) return null;
 try {
 final date = mp['reportdate'];
 return date;
 } catch (ex) {
 print('can not get reportdate');
 return null;
 }
}
String? _getPrioritySr(List<dynamic>? lst) {
 final mp = lst?.first as Map<String, dynamic>?;
 if (mp == null) return null;
 try {
 final priority = mp['reportedpriority_description'];
 return priority;
 } catch (ex) {
 print('can not get priority');
 return null;
 }
}
String? _getFromWhoSr(List<dynamic>? lst) {
 final mp = lst?.first as Map<String, dynamic>?;
 if (mp == null) return null;
 try {
 final fromWho = mp['fromwho'];
 return fromWho;
 } catch (ex) {
 print('can not get fromwho');
 return null;
 }
}
String? _getTicketdescSr(List<dynamic>? lst) {
 final mp = lst?.first as Map<String, dynamic>?;
 if (mp == null) return null;
 try {
 final ticketDesc = mp['ticketdesc'];
 return ticketDesc;
 } catch (ex) {
 print('can not get ticketdesc');
 return null;
 }
}
Map<String, dynamic> _$WorkTaskMobileToJson(WorkTaskMobile instance) =>
 <String, dynamic>{
 'wonum': instance.wonum,
 'description': instance.description,
 'status': instance.status,
 'status_description': instance.statusDescription,
 'targstartdate': instance.targstartdate,
 'targcompdate': instance.targcompdate,
 'siteid': instance.siteid,
 'href': instance.href,
 'worktype': instance.worktype,
 'assetnum': instance.assetnum,
 'offlineScript': instance.offlineScript,
 'owner': instance.owner,
 'rs_week_description': instance.weekDescription,
 'rs_month_description': instance.monthDescription,
 'rs_quarter_description': instance.quarterDescription,
 'rs_year_description': instance.yearDescription,
 'asset': instance.asset,
 'location': instance.location,
 'doclinks': instance.doclinks,
 'woactivity': instance.woactivity,
 'worklog': instance.worklog,
 'started': instance.started,
 'finished': instance.finished,
 'displayName': instance.displayName,
 'priority': instance.priority,
 'timeStampStarted': instance.timeStampStarted,
 'timeStampFinished': instance.timeStampFinished,
 'pprTakenInMaximo': instance.pprTakenInMaximo,
 };
```

## File: lib/data/models/work_task_mobile/wtm_response.dart
```dart
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:json_annotation/json_annotation.dart';
part 'wtm_response.g.dart';
@JsonSerializable()
class WtmResponse {
 final List<WorkTaskMobile>? member;
 WtmResponse({this.member});
 factory WtmResponse.fromJson(Map<String, dynamic> json) => _$WtmResponseFromJson(json);
 Map<String, dynamic> toJson() => _$WtmResponseToJson(this);
}
```

## File: lib/data/models/work_task_mobile/wtm_response.g.dart
```dart
part of 'wtm_response.dart';
WtmResponse _$WtmResponseFromJson(Map<String, dynamic> json) => WtmResponse(
 member: (json['member'] as List<dynamic>?)
 ?.map((e) => WorkTaskMobile.fromJson(e as Map<String, dynamic>))
 .toList(),
 );
Map<String, dynamic> _$WtmResponseToJson(WtmResponse instance) =>
 <String, dynamic>{
 'member': instance.member,
 };
```

## File: lib/data/models/worklog/worklog.dart
```dart
import 'package:json_annotation/json_annotation.dart';
part 'worklog.g.dart';
@JsonSerializable()
class Worklog {
 String? wonum;
 final int? worklogid;
 final String? createby;
 @JsonKey(name: 'createdby_displayname')
 final String? fromName;
 final String? createdate;
 final String? localref;
 final String? description;
 final String? recordkey;
 final bool fresh;
 factory Worklog.fromJson(Map<String, dynamic> json) =>
 _$WorklogFromJson(json);
 Worklog({
 this.wonum,
 this.worklogid,
 this.createby,
 this.fromName,
 this.createdate,
 this.localref,
 this.description,
 this.recordkey,
 this.fresh = false,
 });
 Map<String, dynamic> toJson() => _$WorklogToJson(this);
 Map<String, dynamic> toMap() => {
 'wonum': wonum,
 'worklogid': worklogid,
 'description': description,
 'createby': createby,
 'fromName': fromName,
 'createdate': createdate,
 'recordkey': recordkey,
 'fresh': fresh ? 1 : 0,
 };
 static Worklog fromMap(Map<String, dynamic> map) {
 return Worklog(
 wonum: map['wonum'],
 worklogid: map['worklogid'],
 description: map['description'],
 createby: map['createby'],
 fromName: map['fromName'],
 createdate: map['createdate'],
 recordkey: map['recordkey'],
 fresh: map['fresh'] == 1,
 );
 }
 static const worklogTable = 'WorklogTable';
 static const createWorklogTable = '''
 CREATE TABLE $worklogTable (
 wonum TEXT,
 worklogid INTEGER,
 description TEXT,
 createby TEXT,
 fromName TEXT,
 createdate TEXT,
 recordkey TEXT,
 fresh INTEGER
 );
 ''';
}
```

## File: lib/data/models/worklog/worklog.g.dart
```dart
part of 'worklog.dart';
Worklog _$WorklogFromJson(Map<String, dynamic> json) => Worklog(
 wonum: json['wonum'] as String?,
 worklogid: (json['worklogid'] as num?)?.toInt(),
 createby: json['createby'] as String?,
 fromName: json['createdby_displayname'] as String?,
 createdate: json['createdate'] as String?,
 localref: json['localref'] as String?,
 description: json['description'] as String?,
 recordkey: json['recordkey'] as String?,
 fresh: json['fresh'] as bool? ?? false,
 );
Map<String, dynamic> _$WorklogToJson(Worklog instance) => <String, dynamic>{
 'wonum': instance.wonum,
 'worklogid': instance.worklogid,
 'createby': instance.createby,
 'createdby_displayname': instance.fromName,
 'createdate': instance.createdate,
 'localref': instance.localref,
 'description': instance.description,
 'recordkey': instance.recordkey,
 'fresh': instance.fresh,
 };
```

## File: lib/error/app_error.dart
```dart
class AppError {
 String? message;
 String? statusCode;
 String? reasonCode;
 AppError({
 this.statusCode,
 this.message,
 this.reasonCode,
 });
}
```

## File: lib/error/error_screen.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/error/app_error.dart';
class ErrorScreen extends StatelessWidget {
 const ErrorScreen({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 distinct: true,
 builder: (context, vm) {
 return Scaffold(
 body: Stack(
 children: [
 Image.asset(
 "assets/oops.png",
 fit: BoxFit.cover,
 height: double.infinity,
 width: double.infinity,
 alignment: Alignment.center,
 ),
 Container(color: Colors.white.withOpacity(0.8)),
 Column(
 crossAxisAlignment: CrossAxisAlignment.stretch,
 children: [
 const SizedBox(height: 150),
 const Text(
 Txt.errorTitle,
 textAlign: TextAlign.center,
 style: TextStyle(
 fontSize: 32,
 color: Colors.red,
 fontWeight: FontWeight.w700),
 ),
 const SizedBox(height: 50),
 Padding(
 padding: const EdgeInsets.all(16.0),
 child: Text(
 vm.error?.message ?? '',
 textAlign: TextAlign.center,
 style: const TextStyle(
 fontSize: 18,
 color: Colors.red,
 fontWeight: FontWeight.w500),
 ),
 ),
 ],
 ),
 Positioned(
 bottom: 50,
 left: 50,
 right: 50,
 child: ElevatedButton(
 onPressed: () {
 context.store.dispatch(ClearErrorAction());
 context.go(AppRoute.getRouteByIndex(vm.tabIndex).route);
 },
 child: const Text(Txt.close),
 ),
 ),
 ],
 ),
 );
 });
 }
}
class _VM extends Equatable {
 final AppError? error;
 final int tabIndex;
 _VM(AppState state)
 : error = state.error,
 tabIndex = state.tabIndex;
 @override
 List<Object?> get props => [error, tabIndex];
}
```

## File: lib/error/models/maximo_error_response.dart
```dart
import 'package:inspector_tps/error/app_error.dart';
class MaximoErrorResponse extends AppError {
 MaximoErrorResponse({
 super.statusCode,
 super.message,
 super.reasonCode,
 });
 factory MaximoErrorResponse.fromJson(Map<String, dynamic> json) {
 return MaximoErrorResponse(
 message: json["message"],
 statusCode: json["statusCode"],
 reasonCode: json["reasonCode"],
 );
 }
}
```

## File: lib/home/home_screen.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/connection_indicator.dart';
import 'package:inspector_tps/data/models/user/user_model.dart';
class BottomNavigationPage extends StatefulWidget {
 const BottomNavigationPage({super.key, required this.navigationShell});
 final StatefulNavigationShell navigationShell;
 @override
 State<BottomNavigationPage> createState() => _BottomNavigationPageState();
}
class _BottomNavigationPageState extends State<BottomNavigationPage> {
 bool initialTabSet = false;
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM.fromState(store.state),
 distinct: true,
 onDidChange: (_, vm) {
 if (vm.hasError) {
 context.go(AppRoute.error.route);
 }
 },
 builder: (context, vm) {
 WidgetsBinding.instance.addPostFrameCallback((_) {
 if (!initialTabSet && vm.user != null) {
 initialTabSet = true;
 _switchTab(context, initialTab(vm.user), vm.hiddenTabs);
 }
 });
 return Scaffold(
 body: SizedBox(
 width: double.infinity,
 height: double.infinity,
 child: Center(
 child: Stack(
 children: [
 widget.navigationShell,
 const Positioned(
 top: 20, left: 16, child: ConnectionIndicator()),
 ],
 ),
 ),
 ),
 bottomNavigationBar: BottomNavigationBar(
 type: BottomNavigationBarType.fixed,
 selectedItemColor: primary,
 unselectedItemColor: primary.withOpacity(0.5),
 showUnselectedLabels: true,
 currentIndex: vm.tabIndex,
 items: [
 BottomNavigationBarItem(
 icon: Icon(vm.hiddenTabs.contains(0)
 ? Icons.lock
 : Icons.work_history_sharp),
 label: Txt.tabAudit,
 ),
 const BottomNavigationBarItem(
 icon: Icon(Icons.library_books),
 label: Txt.tabClaims,
 ),
 const BottomNavigationBarItem(
 icon: Icon(Icons.account_tree),
 label: Txt.tabTo,
 ),
 const BottomNavigationBarItem(
 icon: Icon(Icons.person_sharp),
 label: Txt.tabProfile,
 ),
 ],
 onTap: (index) {
 _switchTab(context, index, vm.hiddenTabs);
 },
 ),
 );
 });
 }
 void _switchTab(BuildContext context, int index, List<int> hiddenTabs) {
 if (hiddenTabs.contains(index)) return;
 context.store.dispatch(TabIndexAction(index));
 widget.navigationShell.goBranch(
 index,
 );
 }
}
class _VM extends Equatable {
 final int tabIndex;
 final bool hasError;
 final UserModel? user;
 _VM.fromState(AppState state)
 : hasError = state.hasError,
 tabIndex = state.tabIndex,
 user = state.userState.user;
 List<int> get hiddenTabs => user?.hiddenTabs() ?? [];
 @override
 List<Object?> get props => [tabIndex, hasError, user];
}
```

## File: lib/main.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/api/endpoints.dart';
import 'package:inspector_tps/core/api/maximo_session.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/data/local_storages/shared_prefs.dart';
import 'core/redux/app_state.dart';
import 'core/sl.dart';
void main() async {
 WidgetsFlutterBinding.ensureInitialized();
 await SystemChrome.setPreferredOrientations([
 DeviceOrientation.portraitUp,
 ]);
 if (kReleaseMode) {
 debugPrint = (String? _, {int? wrapWidth}) {};
 }
 await initSl();
 await _initApp();
 runApp(const App());
}
Future<void> _initApp() async {
 final dev = isDev();
 appStore.dispatch(IsDevAction(dev));
 final savedHost = readHost();
 if (savedHost == null) {
 saveHost(Endpoints.devHost);
 }
 sl<MaximoSession>().config();
 userController.getUser();
}
class App extends StatelessWidget {
 const App({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreProvider<AppState>(
 store: appStore,
 child: MaterialApp.router(
 title: Txt.appName,
 theme: ThemeData(
 colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
 useMaterial3: false,
 ).copyWith(
 appBarTheme: const AppBarTheme(
 backgroundColor: primary,
 foregroundColor: Colors.white,
 surfaceTintColor: Colors.white,
 iconTheme: IconThemeData(
 color: Colors.white,
 )
 ),
 ),
 routerConfig: AppNavigator().router,
 ),
 );
 }
}
```

## File: lib/ppr/redux/ppr_actions.dart
```dart
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
sealed class PprAction {}
class SelectedPprAction extends PprAction {
 final WorkTaskMobile ppr;
 SelectedPprAction(this.ppr);
}
class SetPprAction extends PprAction {
 final List<WorkTaskMobile>? pprs;
 SetPprAction(this.pprs);
}
class SetPprFilterAction extends PprAction {
 final PprFilter filter;
 SetPprFilterAction(this.filter);
}
class SetPprTabAction extends PprAction {
 final PprTab tab;
 SetPprTabAction(this.tab);
}
class ClearPprStateAction extends PprAction {}
```

## File: lib/ppr/redux/ppr_reducer.dart
```dart
import 'package:inspector_tps/ppr/redux/ppr_actions.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
PprState pprReducer(PprState state, dynamic action) {
 if (action is SetPprAction) {
 return state.copyWith(pprs: action.pprs);
 } else if (action is SelectedPprAction) {
 return state.copyWith(selectedPpr: action.ppr);
 } else if (action is ClearPprStateAction) {
 return PprState.initial();
 } else if (action is SetPprFilterAction) {
 return state.copyWith(filter: action.filter);
 } else if (action is SetPprTabAction) {
 return state.copyWith(selectedTab: action.tab);
 }
 return state;
}
```

## File: lib/ppr/redux/ppr_state.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
enum PprFilter {
 shift,
 outdated,
 completed,
 all,
}
enum PprTab {
 info(0, 'ИНФО'),
 operations(1, 'ОПЕРАЦИИ'),
 comments(2, 'КОММЕНТАРИИ');
 const PprTab(this.i, this.value);
 final String value;
 final int i;
}
@immutable
class PprState {
 final List<WorkTaskMobile>? pprs;
 final WorkTaskMobile? selectedPpr;
 final PprFilter filter;
 final PprTab selectedTab;
 const PprState._({
 this.pprs,
 this.selectedPpr,
 this.selectedTab = PprTab.info,
 this.filter = PprFilter.all,
 });
 factory PprState.initial() => const PprState._();
 PprState copyWith({
 List<WorkTaskMobile>? pprs,
 WorkTaskMobile? selectedPpr,
 PprFilter? filter,
 PprTab? selectedTab,
 }) {
 return PprState._(
 pprs: pprs ?? this.pprs,
 selectedPpr: selectedPpr ?? this.selectedPpr,
 filter: filter ?? this.filter,
 selectedTab: selectedTab ?? this.selectedTab,
 );
 }
}
```

## File: lib/ppr/redux/ppr_thunks.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/redux/actions.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/sl.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/maximo_repository.dart';
import 'package:inspector_tps/data/models/ppr/woactivity.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_actions.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
import 'package:inspector_tps/ppr/utils.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';
ThunkAction<AppState> downloadPprAction({required String date}) =>
 (store) async {
 if (!store.state.isConnected) {
 return;
 }
 store.dispatch(ShowLoader());
 await userController.checkAuthorization();
 try {
 final ppr = await sl<MaximoRepository>().downloadPprs(date: date);
 await insertPpr(ppr?.member ?? [], fromMaximo: true);
 store.dispatch(readPprsFromDbAction());
 } catch (err) {
 debugPrint('download ppr thunk error: $err');
 } finally {
 store.dispatch(HideLoader());
 }
 };
ThunkAction<AppState> readPprsFromDbAction({bool downloadIfEmpty = false}) =>
 (store) async {
 final filter = store.state.pprState.filter;
 store.dispatch(ShowLoader());
 final List<WorkTaskMobile> savedPpr;
 switch (filter) {
 case PprFilter.shift:
 savedPpr = await readTodayPpr();
 break;
 case PprFilter.outdated:
 savedPpr = await readOutdatedPpr();
 break;
 case PprFilter.completed:
 savedPpr = await readCompletedPpr();
 break;
 default:
 savedPpr = await readAllPpr();
 break;
 }
 store.dispatch(SetPprAction(savedPpr));
 store.dispatch(HideLoader());
 };
ThunkAction<AppState> readSelectedPprFromDbAction(String wonum) =>
 (store) async {
 final ppr = await readPprByWonum(wonum);
 store.dispatch(SelectedPprAction(ppr));
 };
ThunkAction<AppState> addCommentToPprAction(
 {required String wonum, required String comment}) =>
 (store) async {
 await addCommentToWorklogTable(wonum, comment);
 store.dispatch(readSelectedPprFromDbAction(wonum));
 };
ThunkAction<AppState> updateJobtaskResultAction({
 required String wonum,
 required int wosequence,
 required String result,
}) =>
 (store) async {
 await updateJobtaskResult(
 wonum: wonum, wosequence: wosequence, result: result);
 store.dispatch(readSelectedPprFromDbAction(wonum));
 };
ThunkAction<AppState> completePprJobsAction({
 required String wonum,
}) =>
 (store) async {
 await completePprJobs(wonum: wonum);
 store.dispatch(readSelectedPprFromDbAction(wonum));
 };
ThunkAction<AppState> addJobtaskCommentAction({
 required String wonum,
 required int wosequence,
 required String comment,
}) =>
 (store) async {
 await addJobtaskComment(
 wonum: wonum, wosequence: wosequence, comment: comment);
 store.dispatch(readSelectedPprFromDbAction(wonum));
 };
ThunkAction<AppState> takeInWorkPprAction(String wonum) => (store) async {
 store.dispatch(ShowLoader());
 final repo = sl<MaximoRepository>();
 try {
 if (!store.state.isConnected) {
 await takePprInWorkLocally(wonum);
 } else {
 await userController.checkAuthorization();
 final success = await repo.runScript(wonum,
 script: scriptTakeInWork, description: 'take ppr in work');
 if (success) {
 await _downloadAndInsertUpdatedPpr(wonum);
 }
 }
 } catch (err) {
 debugPrint('take in work ppr thunk error: $err');
 } finally {
 _finallyPpr(store, wonum);
 }
 };
ThunkAction<AppState> completePprsByDutyEngAction(List<WorkTaskMobile> pprs) =>
 (store) async {
 if (!store.state.isConnected) return;
 store.dispatch(ShowLoader());
 final repo = sl<MaximoRepository>();
 try {
 await userController.checkAuthorization();
 if (pprs.isEmpty) {
 pprs = await getReadyPprs();
 }
 for (final ppr in pprs) {
 final wonum = ppr.wonum!;
 final List<Woactivity> jobs = await readJobTasksByWonum(wonum ?? '');
 for (final job in jobs) {
 await repo.updateWoactivity(job);
 }
 await sendComments(wonum, ppr.href);
 await uploadWtmImages(wonum, ppr.doclinks?.href);
 final success = await repo.runScript(wonum,
 script: scriptDutyComp, description: 'complete ppr by Duty eng.');
 if (success) {
 await _downloadAndInsertUpdatedPpr(wonum);
 }
 }
 } catch (err) {
 debugPrint('complete ppr by duty thunk error: $err');
 } finally {
 _finallyPpr(store, pprs.length == 1 ? pprs.first.wonum : null);
 }
 };
ThunkAction<AppState> sendForApprovalZdePprAction(
 String wonum, String? href, String? doclinks) =>
 (store) async {
 if (!store.state.isConnected) return;
 store.dispatch(ShowLoader());
 try {
 await userController.checkAuthorization();
 await sendComments(wonum, href);
 await uploadWtmImages(wonum, doclinks);
 final success = await sl<MaximoRepository>().runScript(wonum,
 script: scriptItrComp, description: 'send for approval');
 if (success) {
 await _downloadAndInsertUpdatedPpr(wonum);
 }
 } catch (err) {
 debugPrint('send for zde approval thunk error: $err');
 } finally {
 _finallyPpr(store, wonum);
 }
 };
ThunkAction<AppState> reportEquipmentFailureWithCommentAction(
 String wonum, String? href, String comment, String? doclinks) =>
 (store) async {
 if (!store.state.isConnected) return;
 store.dispatch(ShowLoader());
 await addCommentToWorklogTable(wonum, comment);
 try {
 await userController.checkAuthorization();
 await sendComments(wonum, href);
 await uploadWtmImages(wonum, doclinks);
 final success = await sl<MaximoRepository>().runScript(wonum,
 script: scriptReportEquipmentFailure,
 description: 'reportEquipmentFailureWithCommentAction');
 if (success) {
 await _downloadAndInsertUpdatedPpr(wonum);
 }
 } catch (err) {
 debugPrint('send for zde approval thunk error: $err');
 } finally {
 _finallyPpr(store, wonum);
 }
 };
ThunkAction<AppState> confirmPprAction(
 String wonum, String? href, String? doclinks) =>
 (store) async {
 if (!store.state.isConnected) return;
 store.dispatch(ShowLoader());
 try {
 await userController.checkAuthorization();
 await sendComments(wonum, href);
 await uploadWtmImages(wonum, doclinks);
 final success = await sl<MaximoRepository>().runScript(wonum,
 script: scriptZdeConfirm, description: 'confirm ppr');
 if (success) {
 await _downloadAndInsertUpdatedPpr(wonum);
 }
 } catch (err) {
 debugPrint('confirm ppr thunk error: $err');
 } finally {
 _finallyPpr(store, wonum);
 }
 };
ThunkAction<AppState> cancelPprAction(
 String wonum, String? href, String comment, String? doclinks) =>
 (store) async {
 if (!store.state.isConnected) return;
 store.dispatch(ShowLoader());
 await addCommentToWorklogTable(wonum, comment);
 try {
 await userController.checkAuthorization();
 await sendComments(wonum, href);
 await uploadWtmImages(wonum, doclinks);
 final success = await sl<MaximoRepository>().runScript(wonum,
 script: scriptZdeCancel, description: 'cancel ppr');
 if (success) {
 await _downloadAndInsertUpdatedPpr(wonum);
 }
 } catch (err) {
 debugPrint('cancel ppr thunk error: $err');
 } finally {
 _finallyPpr(store, wonum);
 }
 };
ThunkAction<AppState> sendCommentToMaximoAction(
 String wonum,
 String? href,
 String? doclinks, {
 bool isPpr = true,
}) =>
 (store) async {
 if (!store.state.isConnected) return;
 store.dispatch(ShowLoader());
 try {
 await userController.checkAuthorization();
 final success = await sendComments(wonum, href);
 await uploadWtmImages(wonum, doclinks);
 if (success) {
 if (isPpr) {
 await _downloadAndInsertUpdatedPpr(wonum);
 } else {
 await downloadAndInsertUpdatedRz(wonum);
 }
 }
 } catch (err) {
 debugPrint('sendCommentToMaximoAction error: $err');
 } finally {
 if (isPpr) {
 _finallyPpr(store, wonum);
 } else {
 finallyRz(store, wonum);
 }
 }
 };
Future<void> uploadWtmImages(String wonum, String? doclinks) async {
 if (doclinks == null) return;
 final List<String> images = await readImagesPaths(wonum: wonum);
 debugPrint('uploading ${images.length} images to: $doclinks');
 await maximoRepository.uploadImagesToMaximo(
 paths: images,
 docLink: doclinks,
 table: WorkTaskMobile.imagesTable,
 );
 await deleteSentImages(WorkTaskMobile.imagesTable);
}
void _finallyPpr(Store<AppState> store, String? wonum) {
 if (wonum != null) {
 store.dispatch(readSelectedPprFromDbAction(wonum));
 }
 store.dispatch(readPprsFromDbAction());
 store.dispatch(HideLoader());
}
Future<void> _downloadAndInsertUpdatedPpr(String wonum) async {
 final repo = sl<MaximoRepository>();
 final pprResponse = await repo.downloadWtmByWonum(wonum);
 final updatedPpr = pprResponse?.member?.first;
 debugPrint('upd ppr: $updatedPpr');
 if (updatedPpr != null && updatedPpr.wonum != null) {
 await deletePpr(updatedPpr.wonum!);
 await insertPpr([updatedPpr], fromMaximo: true);
 }
}
ThunkAction<AppState> deleteAllPprAction(List<String> wonums) => (store) async {
 await deleteAllPpr(wonums);
 store.dispatch(ClearPprStateAction());
 await store.dispatch(readPprsFromDbAction());
 };
ThunkAction<AppState> deleteCompletedPprAction() => (store) async {
 final delWonums = await readCompletedPprWonums();
 print(delWonums);
 for (final w in delWonums) {
 await deletePpr(w);
 }
 await store.dispatch(readPprsFromDbAction());
 };
ThunkAction<AppState> deletePprCommentAction(
 {required String wonum, required String comment}) =>
 (store) async {
 await deleteComment(wonum, comment);
 store.dispatch(readSelectedPprFromDbAction(wonum));
 };
```

## File: lib/ppr/utils.dart
```dart
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/data/local_storages/local_db.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:package_info_plus/package_info_plus.dart';
bool isPprReady(WorkTaskMobile ppr) {
 final ready = ppr.woactivity
 ?.map((job) =>
 (job.pprresult == bad &&
 (job.pprcomment != null && job.pprcomment!.isNotEmpty)) ||
 job.pprresult == good)
 .every((e) => e) ??
 false;
 return ppr.status == statusAssigned && ready;
}
Future<List<WorkTaskMobile>> getReadyPprs() async {
 final all = await readAllPpr();
 return all.where((ppr) => isPprReady(ppr)).toList();
}
Future<String> getAppInfo() async {
 PackageInfo packageInfo = await PackageInfo.fromPlatform();
 String buildNumber = packageInfo.buildNumber;
 return '${Txt.version} $buildNumber';
}
```

## File: lib/ppr/view/detailed/add_comment_button.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
class AddCommentButton extends StatelessWidget {
 const AddCommentButton({
 super.key,
 required this.onTap,
 required this.text,
 });
 final VoidCallback onTap;
 final String text;
 @override
 Widget build(BuildContext context) {
 return InkWell(
 onTap: onTap,
 child: Card(
 child: Row(
 children: [
 SvgPicture.asset('assets/add_comment.svg'),
 span10,
 Text(
 text,
 style: const TextStyle(fontSize: 16, color: primary),
 ),
 span10,
 ],
 ),
 ),
 );
 }
}
```

## File: lib/ppr/view/detailed/comment_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/claims/redux/claims_thunk.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/data/models/worklog/worklog.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:inspector_tps/ppr/view/detailed/description.dart';
class CommentCard extends StatelessWidget {
 final Worklog worklog;
 final String? href;
 final String? doclinks;
 final bool isPpr;
 const CommentCard({
 super.key,
 required this.worklog,
 this.href,
 this.doclinks,
 this.isPpr = true,
 });
 @override
 Widget build(BuildContext context) {
 return Container(
 decoration: BoxDecoration(
 borderRadius: const BorderRadius.all(Radius.circular(4)),
 border: Border.all(
 color: bg,
 width: 1,
 ),
 color: worklog.fresh ? primary.withOpacity(0.1) : Colors.white,
 ),
 padding: const EdgeInsets.symmetric(vertical: 5, horizontal: 12),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 if (!worklog.fresh)
 Text(
 'От: ${worklog.fromName ?? worklog.createby ?? '-'}',
 style: const TextStyle(fontSize: 10, color: primary),
 ),
 if (!worklog.fresh)
 Text(
 softWrap: true,
 dateTimeFromIso(worklog.createdate ?? '-'),
 style: const TextStyle(fontSize: 10, color: primary),
 ),
 gap5,
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Expanded(child: Description(title: worklog.description ?? '-')),
 if (worklog.fresh)
 IconButton(
 icon: const Icon(Icons.send),
 onPressed: () async {
 context.store.dispatch(sendCommentToMaximoAction(
 worklog.wonum ?? '', href, doclinks,
 isPpr: isPpr));
 },
 ),
 if (worklog.fresh)
 IconButton(
 icon: const Icon(Icons.close),
 onPressed: () {
 if (isPpr) {
 context.store.dispatch(deletePprCommentAction(
 wonum: worklog.wonum!,
 comment: worklog.description ?? '---'));
 } else {
 context.store.dispatch(deleteRzCommentAction(
 wonum: worklog.wonum!,
 comment: worklog.description ?? '---'));
 }
 },
 ),
 ],
 ),
 ],
 ),
 );
 }
}
```

## File: lib/ppr/view/detailed/comments_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/data/models/worklog/worklog.dart';
import 'package:inspector_tps/ppr/view/detailed/add_comment_button.dart';
import 'package:inspector_tps/ppr/view/detailed/comment_card.dart';
class CommentsView extends StatelessWidget {
 const CommentsView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 if (vm.showLoader) {
 return const LoaderWithDescription();
 }
 return Expanded(
 child: SingleChildScrollView(
 child: Column(
 mainAxisAlignment: MainAxisAlignment.start,
 children: [
 gap10,
 AddCommentButton(
 text: Txt.addPprComment,
 onTap: () => _addComment(context, vm.selectedPpr),
 ),
 gap10,
 if (vm.freshComments.isNotEmpty) Text(Txt.fresh),
 ...vm.freshComments.map((comment) => Padding(
 padding: const EdgeInsets.only(top: 4.0),
 child: CommentCard(
 worklog: comment,
 href: vm.selectedPpr.href,
 doclinks: vm.selectedPpr.doclinks?.href,
 ),
 )),
 gap10,
 if (vm.downloadedComments.isNotEmpty) Text(Txt.downloaded),
 ...vm.downloadedComments.map((comment) => Padding(
 padding: const EdgeInsets.only(top: 4.0),
 child: CommentCard(
 worklog: comment,
 ),
 )),
 ],
 ),
 ),
 );
 },
 );
 }
 void _addComment(BuildContext context, WorkTaskMobile ppr) {
 addPprCommentDialogWithAction(context, ppr, isPhotoComment: false);
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 WorkTaskMobile get selectedPpr => appState.pprState.selectedPpr!;
 List<Worklog> get comments => selectedPpr.worklog ?? [];
 List<Worklog> get downloadedComments =>
 comments.where((c) => !c.fresh).toList();
 List<Worklog> get freshComments => comments.where((c) => c.fresh).toList();
 bool get showLoader => appState.showLoader;
 @override
 List<Object?> get props => [
 selectedPpr.worklog?.length ?? 0,
 selectedPpr.images,
 showLoader,
 ];
}
```

## File: lib/ppr/view/detailed/description.dart
```dart
import 'package:flutter/material.dart';
class Description extends StatelessWidget {
 final String title;
 const Description({super.key, required this.title});
 @override
 Widget build(BuildContext context) {
 return Text(title,
 softWrap: true,
 style: const TextStyle(
 color: Colors.black,
 fontSize: 14,
 fontWeight: FontWeight.w400,
 ));
 }
}
```

## File: lib/ppr/view/detailed/info_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
class InfoCard extends StatelessWidget {
 const InfoCard(
 {super.key, required this.title, required this.subTitle, this.color});
 final String title;
 final String subTitle;
 final Color? color;
 @override
 Widget build(BuildContext context) {
 return Container(
 width: double.infinity,
 decoration: BoxDecoration(
 borderRadius: const BorderRadius.all(Radius.circular(4)),
 border: Border.all(
 color: bg,
 width: 1,
 ),
 color: Colors.white,
 ),
 padding: const EdgeInsets.symmetric(vertical: 5, horizontal: 12),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 _Title(title),
 gap5,
 _SubTitle(
 subTitle,
 color: color,
 ),
 ],
 ),
 );
 }
}
class _Title extends StatelessWidget {
 final String title;
 const _Title(this.title);
 @override
 Widget build(BuildContext context) {
 return Text(title,
 style: const TextStyle(
 color: primary,
 fontSize: 12,
 fontWeight: FontWeight.w400,
 ));
 }
}
class _SubTitle extends StatelessWidget {
 final String subtitle;
 final Color? color;
 const _SubTitle(this.subtitle, {this.color});
 @override
 Widget build(BuildContext context) {
 return Text(subtitle,
 style: TextStyle(
 color: color ?? Colors.black,
 fontSize: 14,
 fontWeight: FontWeight.w700,
 ));
 }
}
```

## File: lib/ppr/view/detailed/info_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/audit/view/checklist/images_row.dart';
import 'package:inspector_tps/core/camera/camera_screen.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/core/widgets/unsaved_icon_button.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/data/models/worklog/worklog.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:inspector_tps/ppr/view/detailed/info_card.dart';
class InfoView extends StatefulWidget {
 const InfoView({super.key});
 @override
 State<InfoView> createState() => _InfoViewState();
}
class _InfoViewState extends State<InfoView> {
 bool dialogShown = false;
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 onWillChange: (_, vm) {
 if (vm.shouldAddComment && !dialogShown) {
 dialogShown = true;
 _addComment(context, vm.selectedPpr);
 }
 },
 builder: (context, vm) {
 final bool assigned = vm.status == statusAssigned;
 if (vm.showLoader) {
 return const LoaderWithDescription();
 } else {
 return Expanded(
 child: Column(
 children: [
 InfoCard(title: Txt.plannedJob, subTitle: vm.plannedJob),
 gap10,
 Row(
 children: [
 Expanded(
 child: InfoCard(
 title: Txt.statusCond,
 subTitle: vm.statusDescription.toUpperCase(),
 color: assigned ? positive : primary),
 ),
 if (assigned && !vm.selectedPpr.pprTakenInMaximo)
 const Padding(
 padding: EdgeInsets.only(left: 5.0),
 child: UnsavedIconButton(),
 ),
 ],
 ),
 gap10,
 InfoCard(title: Txt.assetLocation, subTitle: vm.location),
 gap10,
 InfoCard(
 title: Txt.assetDescription,
 subTitle: vm.assetDescription),
 gap10,
 InfoCard(title: Txt.plannedStart, subTitle: vm.start),
 gap10,
 InfoCard(title: Txt.plannedFinish, subTitle: vm.finish),
 gap10,
 if (vm.showTakeInWork)
 ElevatedButton(
 onPressed: () {
 context.store.dispatch(
 takeInWorkPprAction(vm.selectedPpr.wonum!));
 },
 style: _buttonStyle(),
 child: Text(Txt.takeInWork.toUpperCase()),
 ),
 if (vm.showSendForApprovalZde)
 Column(
 children: [
 ElevatedButton(
 onPressed: () {
 context.store.dispatch(sendForApprovalZdePprAction(
 vm.selectedPpr.wonum!,
 vm.selectedPpr.href,
 vm.selectedPpr.doclinks?.href));
 },
 style: ElevatedButton.styleFrom(
 minimumSize: const Size.fromHeight(40),
 shape: const StadiumBorder(),
 backgroundColor: primary),
 child: Text(Txt.sendForApprovalZde),
 ),
 gap20,
 ElevatedButton(
 onPressed: () {
 addPprCommentDialogWithAction(
 context, vm.selectedPpr,
 reportEquipmentFailure: true,
 isPhotoComment: false);
 },
 style: ElevatedButton.styleFrom(
 minimumSize: const Size.fromHeight(40),
 shape: const StadiumBorder(),
 backgroundColor: accent),
 child: Text(
 Txt.reportEquipmentFailure,
 ),
 ),
 gap10,
 Text(Txt.registerToDescription,
 textAlign: TextAlign.center,
 style: const TextStyle(
 fontStyle: FontStyle.italic,
 fontSize: 12,
 fontWeight: FontWeight.bold)),
 ],
 ),
 if (vm.showButtonsConfirmAndReject)
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 ElevatedButton(
 onPressed: () {
 context.store.dispatch(confirmPprAction(
 vm.selectedPpr.wonum!,
 vm.selectedPpr.href,
 vm.selectedPpr.doclinks?.href));
 },
 style: _buttonStyle(),
 child: Text(Txt.confirm),
 ),
 ElevatedButton(
 onPressed: () {
 addPprCommentDialogWithAction(
 context, vm.selectedPpr,
 reject: true, isPhotoComment: false);
 },
 style: ElevatedButton.styleFrom(
 shape: const StadiumBorder(),
 backgroundColor: accent),
 child: Text(Txt.reject),
 ),
 ],
 ),
 if (vm.images.length < 6)
 ElevatedButton(
 onPressed: () {
 dialogShown = false;
 attachPhoto(context,
 wonum: vm.selectedPpr.wonum!,
 checklistwoid: null,
 mode: CameraMode.ppr);
 },
 child: const Icon(Icons.camera_alt_outlined)),
 gap10,
 ImagesRow(
 images: vm.images,
 wonum: vm.selectedPpr.wonum,
 mode: CameraMode.ppr,
 ),
 const Spacer(),
 ],
 ),
 );
 }
 });
 }
 void _addComment(BuildContext context, WorkTaskMobile ppr) {
 addPprCommentDialogWithAction(context, ppr, isPhotoComment: true);
 }
 ButtonStyle _buttonStyle() => ElevatedButton.styleFrom(
 shape: const StadiumBorder(), backgroundColor: primary);
}
class _VM extends Equatable {
 _VM(this.appState);
 final AppState appState;
 WorkTaskMobile get selectedPpr => appState.pprState.selectedPpr!;
 bool get showTakeInWork =>
 (status == statusApproved || status == statusRejected) &&
 (appState.userState.user?.isDutyEng ?? false);
 bool get showSendForApprovalZde =>
 status == statusCompleted && (appState.userState.user?.isItr ?? false);
 bool get showButtonsConfirmAndReject =>
 status == statusPreApproved &&
 (appState.userState.user?.isFilManager ?? false);
 String get status => selectedPpr.status ?? '';
 String get statusDescription => selectedPpr.statusDescription ?? '';
 String get start => dateTimeFromIso(selectedPpr.targstartdate ?? '');
 String get finish => dateTimeFromIso(selectedPpr.targcompdate ?? '');
 bool get showLoader => appState.showLoader;
 List<String> get images => selectedPpr.images;
 String get plannedJob => '${selectedPpr.wonum} \u2022 '
 '${selectedPpr.worktype} \u2022 '
 '${selectedPpr.description?.replaceFirst('ТО', '')}';
 String get assetDescription => selectedPpr.asset?.description ?? '';
 String get location => '${(selectedPpr.location?.description ?? '')} \u2022 '
 '${(selectedPpr.location?.olddescription ?? '')}';
 List<Worklog> get comments => selectedPpr.worklog ?? [];
 List<Worklog> get downloadedComments =>
 comments.where((c) => !c.fresh).toList();
 List<Worklog> get freshComments => comments.where((c) => c.fresh).toList();
 PprTab get selectedTab => appState.pprState.selectedTab;
 bool get shouldAddComment =>
 images.isNotEmpty &&
 freshComments.isEmpty &&
 (selectedTab == PprTab.info);
 @override
 List<Object?> get props =>
 [appState, showLoader, status, images, comments, selectedTab];
}
```

## File: lib/ppr/view/detailed/job_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/ppr/woactivity.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:inspector_tps/ppr/view/detailed/description.dart';
class JobCard extends StatelessWidget {
 final Woactivity job;
 const JobCard({super.key, required this.job});
 @override
 Widget build(BuildContext context) {
 return Padding(
 padding: const EdgeInsets.all(4.0),
 child: Container(
 width: double.infinity,
 decoration: BoxDecoration(
 borderRadius: const BorderRadius.all(Radius.circular(4)),
 border: Border.all(
 color: grayMiddle,
 width: 1,
 ),
 color: Colors.white,
 ),
 padding: const EdgeInsets.symmetric(vertical: 5, horizontal: 12),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Description(title: job.description ?? '-'),
 gap5,
 Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 IconButton(
 onPressed: () {
 addJobCommentDialog(context, job);
 },
 icon: SvgPicture.asset('assets/add_comment.svg',
 width: 44, height: 36)),
 _Jptask(job.wosequence?.toString() ?? '-'),
 ResultDropdown(job: job),
 ],
 ),
 if (job.pprcomment != null) ...[
 Text(
 '${Txt.comment}:',
 style: const TextStyle(fontSize: 10, color: primary),
 ),
 Text(
 job.pprcomment!,
 style: const TextStyle(fontSize: 10, color: accent),
 ),
 ],
 Text('${Txt.estDur} ${((job.estdur ?? 0.15) * 60).toInt()}',
 style: const TextStyle(fontSize: 10))
 ],
 ),
 ),
 );
 }
}
class ResultDropdown extends StatelessWidget {
 const ResultDropdown({super.key, required this.job});
 final Woactivity job;
 @override
 Widget build(BuildContext context) {
 return DropdownButton<String>(
 value: job.pprresult,
 items: jobResults
 .map((result) => DropdownMenuItem<String>(
 value: result,
 child: Text(result),
 ))
 .toList(),
 onChanged: (value) {
 if (value != null) {
 context.store.dispatch(updateJobtaskResultAction(
 wonum: job.wonum!,
 wosequence: job.wosequence ?? -1,
 result: value,
 ));
 }
 },
 );
 }
}
class _Jptask extends StatelessWidget {
 final String opNumber;
 const _Jptask(this.opNumber);
 @override
 Widget build(BuildContext context) {
 return Text(opNumber,
 style: const TextStyle(
 color: primary,
 fontSize: 16,
 fontWeight: FontWeight.w700,
 ));
 }
}
```

## File: lib/ppr/view/detailed/operations_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/dialogs.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/data/models/ppr/woactivity.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:inspector_tps/ppr/utils.dart';
import 'package:inspector_tps/ppr/view/detailed/job_card.dart';
class OperationsView extends StatelessWidget {
 const OperationsView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 final listSize = vm.jobs.length + 1;
 return vm.showLoader
 ? const LoaderWithDescription()
 : Expanded(
 child: ListView.builder(
 itemCount: listSize,
 itemBuilder: (context, index) {
 if (index == listSize - 1) {
 return vm.selectedPpr.status == statusAssigned
 ? Padding(
 padding: const EdgeInsets.only(top: 12.0),
 child: Row(
 mainAxisAlignment:
 MainAxisAlignment.spaceBetween,
 children: [
 ElevatedButton(
 onPressed: vm.completed
 ? null
 : () {
 context.store.dispatch(
 completePprJobsAction(
 wonum: vm.selectedPpr
 .wonum!));
 },
 style: ElevatedButton.styleFrom(
 shape: const StadiumBorder(),
 backgroundColor: vm.completed
 ? grayMiddle
 : accent),
 child: Text(
 Txt.allOperationsCompleted
 .toUpperCase(),
 style: _buttonTxtStyle,
 ),
 ),
 ElevatedButton(
 onPressed: vm.completed
 ? () {
 if (!context
 .store.state.isConnected) {
 infoDialog(context,
 message: Txt.offline);
 } else {
 context.store.dispatch(
 completePprsByDutyEngAction(
 [vm.selectedPpr],
 ));
 }
 }
 : () {
 infoDialog(context,
 message: Txt
 .completePprDescription);
 },
 style: ElevatedButton.styleFrom(
 shape: const StadiumBorder(),
 backgroundColor: vm.completed
 ? accent
 : grayMiddle),
 child: Text(Txt.finish.toUpperCase(),
 style: _buttonTxtStyle),
 ),
 ],
 ))
 : const SizedBox.shrink();
 }
 final job = vm.jobs[index];
 return JobCard(job: job);
 }),
 );
 });
 }
}
const _buttonTxtStyle = TextStyle(fontSize: 12);
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 WorkTaskMobile get selectedPpr => appState.pprState.selectedPpr!;
 List<Woactivity> get jobs => selectedPpr.woactivity ?? [];
 bool get showLoader => appState.showLoader;
 bool get completed => isPprReady(selectedPpr);
 @override
 List<Object?> get props => [jobs, showLoader];
}
```

## File: lib/ppr/view/detailed/ppr_detailed_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:inspector_tps/ppr/view/detailed/comments_view.dart';
import 'package:inspector_tps/ppr/view/detailed/info_view.dart';
import 'package:inspector_tps/ppr/view/detailed/operations_view.dart';
import 'package:inspector_tps/ppr/view/detailed/tabs_switcher.dart';
class PprDetailedView extends StatelessWidget {
 const PprDetailedView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 return Scaffold(
 backgroundColor: bg,
 appBar: AppBar(
 leading: InkWell(
 onTap: () => _handleBack(context, vm),
 child: const Icon(
 Icons.arrow_back,
 color: Colors.white,
 ),
 ),
 title: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 Text(
 vm.selectedPpr.description ?? '',
 maxLines: 2,
 style: const TextStyle(fontSize: 13),
 ),
 ],
 ),
 actions: [
 if (vm.isConnected)
 PopupMenuButton<int>(
 icon: const Icon(Icons.more_vert),
 onSelected: (index) =>
 _handleMenuClick(context, index, vm.selectedPpr),
 itemBuilder: (context) => [
 PopupMenuItem<int>(
 value: 0,
 child: Text(
 Txt.sendChanges,
 )),
 ],
 ),
 ],
 ),
 body: Padding(
 padding: const EdgeInsets.symmetric(horizontal: 16.0),
 child: Column(
 children: [
 gap20,
 const TabsSwitcher(),
 gap20,
 if (vm.selectedTab == PprTab.info) const InfoView(),
 if (vm.selectedTab == PprTab.operations)
 const OperationsView(),
 if (vm.selectedTab == PprTab.comments) const CommentsView(),
 ],
 ),
 ),
 );
 });
 }
 void _handleMenuClick(BuildContext context, int index, WorkTaskMobile ppr) {
 switch (index) {
 case 0:
 context.store.dispatch(
 sendCommentToMaximoAction(
 ppr.wonum ?? '', ppr.href, ppr.doclinks?.href,
 isPpr: true),
 );
 break;
 default:
 break;
 }
 }
 void _handleBack(BuildContext context, _VM vm) {
 context.go(AppRoute.ppr.route);
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 bool get showLoader => appState.showLoader;
 WorkTaskMobile get selectedPpr => appState.pprState.selectedPpr!;
 PprTab get selectedTab => appState.pprState.selectedTab;
 bool get isConnected => appState.isConnected;
 @override
 List<Object?> get props => [
 showLoader,
 selectedTab,
 selectedPpr,
 isConnected,
 ];
}
```

## File: lib/ppr/view/detailed/tabs_switcher.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/ppr/redux/ppr_actions.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
class TabsSwitcher extends StatelessWidget {
 const TabsSwitcher({super.key});
 @override
 Widget build(BuildContext context) {
 final buttonWidth = (MediaQuery.of(context).size.width - 32 - 20) / 3;
 return StoreConnector<AppState, PprTab>(
 converter: (store) => store.state.pprState.selectedTab,
 builder: (context, tab) {
 return ToggleButtons(
 onPressed: (int index) {
 context.store.dispatch(SetPprTabAction(_tabs[index]));
 },
 borderRadius: const BorderRadius.all(Radius.circular(4)),
 borderWidth: 5,
 borderColor: grayMiddle,
 selectedColor: primary,
 color: primary,
 constraints: BoxConstraints(
 minHeight: 30.0,
 minWidth: buttonWidth,
 ),
 isSelected: [
 tab == PprTab.info,
 tab == PprTab.operations,
 tab == PprTab.comments,
 ],
 children: [
 _getTabWidget(0, buttonWidth, tab),
 _getTabWidget(1, buttonWidth, tab),
 _getTabWidget(2, buttonWidth, tab),
 ],
 );
 });
 }
}
const _tabs = PprTab.values;
Widget _getTabWidget(
 int index,
 double width,
 PprTab selectedTab,
) {
 final tab = _tabs[index];
 final bool isSelected = tab == selectedTab;
 return Container(
 height: 30,
 width: width,
 color: isSelected ? Colors.white : grayMiddle,
 child: Center(
 child: Text(
 tab.value,
 style: const TextStyle(
 fontWeight: FontWeight.bold,
 fontSize: 12,
 ),
 ),
 ));
}
```

## File: lib/ppr/view/no_ppr_widget.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/redux/app_state.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
class NoPprWidget extends StatelessWidget {
 const NoPprWidget({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 builder: (context, vm) {
 return Center(
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.center,
 children: [
 const Spacer(),
 Text(vm.shouldDownload ? Txt.noPpr : Txt.noPprForShift,
 textAlign: TextAlign.center,
 style: const TextStyle(fontSize: 25)),
 const SizedBox(height: 150),
 if (vm.shouldDownload)
 ElevatedButton(
 style: ElevatedButton.styleFrom(backgroundColor: primary),
 onPressed: () {
 context.store
 .dispatch(downloadPprAction(date: monthAgoIso(monthsCount: 6)));
 },
 child: Text(Txt.downloadPprMonth)),
 const Spacer(),
 ],
 ),
 );
 });
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 List<WorkTaskMobile> get pprs => appState.pprState.pprs ?? [];
 PprFilter get filter => appState.pprState.filter;
 bool get shouldDownload => pprs.isEmpty && filter == PprFilter.all;
 @override
 List<Object?> get props => [pprs, filter];
}
```

## File: lib/ppr/view/ppr_card.dart
```dart
import 'package:flutter/material.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/utils/time_utils.dart';
import 'package:inspector_tps/core/widgets/card_divider.dart';
import 'package:inspector_tps/core/widgets/unsaved_icon_button.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/utils.dart';
class PprCard extends StatelessWidget {
 const PprCard({super.key, required this.ppr, this.showReady = false});
 final WorkTaskMobile ppr;
 final bool showReady;
 @override
 Widget build(BuildContext context) {
 final textTheme = Theme.of(context).textTheme;
 final textStyle = textTheme.bodyMedium?.copyWith(color: primary);
 final dateStyle = textTheme.labelMedium
 ?.copyWith(fontWeight: FontWeight.bold, color: primary);
 final headerStyle = dateStyle?.copyWith(fontSize: 10);
 Widget dateRow = Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Text(dateTimeFromIso(ppr.targstartdate ?? ''), style: dateStyle),
 Text(dateTimeFromIso(ppr.targcompdate ?? ''), style: dateStyle),
 ],
 );
 final bool assigned = ppr.status == statusAssigned;
 final bool preApproved = ppr.status == statusPreApproved;
 Widget header = Row(
 mainAxisAlignment: MainAxisAlignment.spaceBetween,
 children: [
 Text(ppr.wonum.toString(), style: headerStyle),
 Text(ppr.worktype ?? '', style: headerStyle),
 Row(
 children: [
 if (assigned && !ppr.pprTakenInMaximo) const UnsavedIconButton(),
 Row(
 children: [
 if (isPprReady(ppr)) const ReadyIcon(),
 Text(
 ppr.statusDescription?.toUpperCase() ?? '',
 style: headerStyle?.copyWith(
 color: assigned || preApproved ? positive : primary,
 ),
 ),
 ],
 ),
 ],
 ),
 ],
 );
 return Card(
 elevation: 1,
 color: ppr.status == statusCompleted || ppr.status == statusFullyCompleted
 ? grayMiddle
 : ppr.status == statusRejected
 ? redBg
 : white,
 child: Padding(
 padding: const EdgeInsets.all(8.0),
 child: Column(
 crossAxisAlignment: CrossAxisAlignment.start,
 children: [
 header,
 gap10,
 Text(
 ppr.description ?? '',
 style: textStyle,
 ),
 gap10,
 Text(
 ppr.asset?.description ?? '',
 style: textStyle,
 ),
 gap10,
 const CardDivider(),
 gap10,
 dateRow,
 ],
 ),
 ),
 );
 }
}
class ReadyIcon extends StatelessWidget {
 const ReadyIcon({super.key});
 @override
 Widget build(BuildContext context) {
 return const Icon(Icons.check, color: accent);
 }
}
```

## File: lib/ppr/view/ppr_view.dart
```dart
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:inspector_tps/core/colors.dart';
import 'package:inspector_tps/core/constants.dart';
import 'package:inspector_tps/core/txt.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/core/widgets/loader_with_description.dart';
import 'package:inspector_tps/core/widgets/round_count_widget.dart';
import 'package:inspector_tps/core/widgets/unsupported_for_groups_widget.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_actions.dart';
import 'package:inspector_tps/ppr/redux/ppr_state.dart';
import 'package:inspector_tps/ppr/redux/ppr_thunks.dart';
import 'package:inspector_tps/ppr/view/no_ppr_widget.dart';
import 'package:inspector_tps/ppr/view/pprs_list.dart';
import '../../core/redux/app_state.dart';
class PprView extends StatelessWidget {
 const PprView({super.key});
 @override
 Widget build(BuildContext context) {
 return StoreConnector<AppState, _VM>(
 converter: (store) => _VM(store.state),
 distinct: true,
 onInit: (store) {
 if (store.state.userState.showPpr) {
 store.dispatch(readPprsFromDbAction(downloadIfEmpty: true));
 }
 },
 builder: (context, vm) {
 return vm.showPpr
 ? Scaffold(
 backgroundColor: bg,
 appBar: AppBar(
 leading: PopupMenuButton<int>(
 icon: const Icon(Icons.filter_list),
 onSelected: (index) => handleFilterClick(context, index),
 itemBuilder: (context) => [
 PopupMenuItem<int>(
 value: 0,
 enabled: vm.filter != PprFilter.shift,
 child: Text(
 Txt.currentShift,
 )),
 PopupMenuItem<int>(
 value: 1,
 enabled: vm.filter != PprFilter.outdated,
 child: Text(
 Txt.outdated,
 style: const TextStyle(),
 )),
 PopupMenuItem<int>(
 value: 2,
 enabled: vm.filter != PprFilter.all,
 child: Text(
 Txt.allPpr,
 style: const TextStyle(),
 )),
 PopupMenuItem<int>(
 value: 3,
 enabled: vm.filter != PprFilter.completed,
 child: Text(
 Txt.completedPpr,
 style: const TextStyle(),
 )),
 PopupMenuItem<int>(
 value: 100,
 child: Text(
 Txt.cancel,
 style: const TextStyle(),
 )),
 ],
 ),
 title: Row(
 mainAxisAlignment: MainAxisAlignment.center,
 children: [
 Text(vm.filterName,
 style: const TextStyle(fontSize: 15)),
 span10,
 RoundCountWidget(count: vm.count),
 ],
 ),
 actions: [
 PopupMenuButton<int>(
 icon: const Icon(Icons.more_vert),
 onSelected: (index) => _handleMenuClick(context, index, vm),
 itemBuilder: (context) => [
 PopupMenuItem<int>(
 value: 0,
 child: Text(
 Txt.clearPprList,
 style: const TextStyle(color: Colors.red),
 )),
 PopupMenuItem<int>(
 value: 1,
 child: Text(
 Txt.clearCompletedPpr,
 style: const TextStyle(),
 )),
 PopupMenuItem<int>(
 value: 2,
 child: Text(
 Txt.sendReadyPpr,
 style: const TextStyle(),
 )),
 PopupMenuItem<int>(
 value: 100,
 child: Text(
 Txt.closeMenu,
 style: const TextStyle(),
 )),
 ],
 ),
 ],
 ),
 body: vm.showLoader
 ? const Padding(
 padding: EdgeInsets.symmetric(
 vertical: 50.0, horizontal: 16),
 child: LoaderWithDescription(),
 )
 : vm.pprs.isEmpty
 ? const NoPprWidget()
 : PprsList(pprs: vm.pprs))
 : const UnsupportedForGroupsWidget();
 });
 }
 void _handleMenuClick(BuildContext context, int index, _VM vm) {
 switch (index) {
 case 0:
 context.store.dispatch(deleteAllPprAction(vm.allPprWonums));
 break;
 case 1:
 context.store.dispatch(deleteCompletedPprAction());
 break;
 case 2:
 context.store.dispatch(completePprsByDutyEngAction([]));
 break;
 default:
 break;
 }
 }
 void handleFilterClick(BuildContext context, int index) {
 switch (index) {
 case 0:
 context.store.dispatch(SetPprFilterAction(PprFilter.shift));
 context.store.dispatch(readPprsFromDbAction());
 break;
 case 1:
 context.store.dispatch(SetPprFilterAction(PprFilter.outdated));
 context.store.dispatch(readPprsFromDbAction());
 break;
 case 2:
 context.store.dispatch(SetPprFilterAction(PprFilter.all));
 context.store.dispatch(readPprsFromDbAction());
 break;
 case 3:
 context.store.dispatch(SetPprFilterAction(PprFilter.completed));
 context.store.dispatch(readPprsFromDbAction());
 break;
 default:
 break;
 }
 }
}
class _VM extends Equatable {
 const _VM(this.appState);
 final AppState appState;
 bool get showLoader => appState.showLoader;
 List<WorkTaskMobile> get pprs => appState.pprState.pprs ?? [];
 bool get showPpr => appState.userState.showPpr;
 int get count => pprs.length;
 PprFilter get filter => appState.pprState.filter;
 List<String> get allPprWonums => pprs.map((ppr) => ppr.wonum ?? '').toList();
 String get filterName => switch (filter) {
 PprFilter.all => Txt.allPpr,
 PprFilter.shift => Txt.currentShift,
 PprFilter.outdated => Txt.outdated,
 PprFilter.completed => Txt.completedPpr,
 };
 @override
 List<Object?> get props => [pprs, showLoader, filter];
}
```

## File: lib/ppr/view/pprs_list.dart
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:inspector_tps/core/router.dart';
import 'package:inspector_tps/core/utils/core_utils.dart';
import 'package:inspector_tps/data/models/work_task_mobile/work_task_mobile.dart';
import 'package:inspector_tps/ppr/redux/ppr_actions.dart';
import 'package:inspector_tps/ppr/view/ppr_card.dart';
class PprsList extends StatelessWidget {
 const PprsList({super.key, required this.pprs});
 final List<WorkTaskMobile> pprs;
 @override
 Widget build(BuildContext context) {
 return Padding(
 padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 10),
 child: Scrollbar(
 child: ListView.builder(
 itemCount: pprs.length,
 itemBuilder: (context, index) {
 final ppr = pprs[index];
 return InkWell(
 child: PprCard(ppr: ppr),
 onTap: () {
 debugPrint(ppr.toString());
 context.store.dispatch(SelectedPprAction(ppr));
 context.go(AppRoute.pprDetailed.route);
 },
 );
 },
 ),
 ),
 );
 }
}
```

